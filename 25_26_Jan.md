## USACO 2026 January Contest, Silver

### Problem 1. Lineup Queries

🧩 题意：第0头牛移动到[t/2]处，[t/2]前的每一头牛都往前移一位，每次迭代都在队尾加入t。询问1：牛c在时间t后的位置。询问2.时间t后，位置x上是哪头牛。

🎯 思路：如果某头牛在时间 `t` 之前位于队首，那么它在执行队首移到 t后，会被放到大约 t/2 的位置；要再回到队首，至少还要等它向前“走完”这 t/2步，所以回到队首的时间至少是t+1+t/2。由于 t ≤10^18，因此不能用简单的模拟。

### 📌 Type 1：cow c 在时间 t 后的位置

1. 牛 i 在时间 2i 之前不会动：因为它刚加入时在位置 i，而只有位置 ≤⌊t/2⌋ 的区域会被“前移/插入”影响；当 t<2i 时，⌊t/2⌋<i 它一直不在被影响的前半段里，所以位置恒为 i。
2. 若在某个时刻（执行操作前）它在位置 p，那么在接下来的 p 次操作里，它每次都会往前挪 1 格（因为前半段整体前移），所以 经过 p 步到达队首。
3. 一旦它到达队首，在下一次操作会被直接扔到 ⌊当前时刻/2⌋。

于是我们对单头牛做“循环模拟”：

- 如果剩余时间不够它走到队首：直接返回p−Δ。
- 否则让它走到队首（耗时 p），再执行一次“扔到中间”（耗时 1），位置变成 ⌊cur/2⌋。
   因为“到队首”的次数是对数级，所以总步数是 O(logt)。

### 📌 Type 2：问时间 t 后，位置 x 上是哪头牛

定义 c(p,t) 表示“时间 t 后位置 p 的牛”。可以直接从一步演化推出递推：

- 若 p>⌊t/2⌋，这些位置完全不受当步影响（只是在末尾追加新牛），所以  **c(p,t)=p**。

- 若 p=⌊t/2⌋，这一格正好接收了“上一步的队首牛”，所以
  $$
  c(\lfloor t/2\rfloor, t)=c(0,t-1).
  $$
  
- 若 p<⌊t/2⌋，那么位置 1…⌊t/2⌋ 整体前移一格，所以
  $$
  c(p,t)=c(p+1,t-1).
  $$
  

如果每次只做p←p+1,t←t−1 会变成 O(t)。优化做法是一次跳 Δ步，找一个“保守但足够大”的 且一直满足“在左侧区域”条件。x+k约等于(t-k)/2算出k约等于⌊(t−2p)/3⌋给出：
$$
\Delta=\max\left(1,\left\lfloor\frac{t-2p}{3}\right\rfloor\right).
$$
这样 t 会以常数比例下降，整体仍是 **O(log t)**。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long ll;

/*
  query_type_1是给定 cow c 和 time t，问“时间 t 操作执行完之后，cow c 的位置是多少”。
  - cur_t：当前我们已经模拟到“时间 cur_t 操作执行完之后”的状态
  - cur_pos：此时 cow c 的位置
  返回模拟位置
*/
ll query_type_1(ll c, ll t) {
    // 先把“cow c 加入队列后的状态”当作起点，再向后模拟
    ll cur_t = c;
    ll cur_pos = c;
    while (cur_t < t) {
        // next_step 表示下一次要执行的是“时间 cur_t+1 的操作”
        ll next_step = cur_t + 1;
        // L = floor((cur_t+1)/2)，即下一次操作时，被影响（发生整体前移、并插入队首牛）的区间上界
        // 下一次操作规则：
        //   - 位置 0 的牛被移到 L
        //   - 位置 1..L 的牛整体前移一格（位置减 1）
        //   - 新牛 next_step 加到队尾
        ll L = next_step / 2;
        // 如果 cow c 当前在位置 > L：
        // 那么在下一次操作中，它不在“被整体前移”的区间内，也不会被搬动，
        // 但为了加速，我们尝试“跳过若干步”，直到它可能进入会受影响的前半段。
        if (cur_pos > L) {
            // 经验/推导：当时间达到 2*cur_pos 时，floor(time/2) 会 >= cur_pos，
            // cow c 才可能落入被影响区间
            // 所以 target_time = 2*cur_pos 作为“可能开始受影响的时间点”。
            ll target_time = 2 * cur_pos;
            // 如果这个时间点已经超过查询目标 t，
            // 说明在 [cur_t+1 .. t] 的所有操作中 cow c 都不会受影响，
            // 位置保持 cur_pos 不变，直接返回。
            if (target_time > t) {
                return cur_pos;
            }
            // 否则，我们把 cur_t 尽量跳到 target_time-1，
            // 这样下一轮循环就会处理“时间 target_time 的操作”。
            ll jump_to = target_time - 1;
            if (jump_to > cur_t) {
                cur_t = jump_to;
            } else {
                // 理论上不会太常发生：确保 cur_t 总能前进，避免死循环
                cur_t++;
            }
        } else {
            // 走到这里说明 cow c 在下一次操作时属于“前半段（<=L）”，会受影响。
            // 分两种情况：
            if (cur_pos == 0) {
                // 如果 cow c 恰好在队首（位置 0）：
                // 在下一次操作中它会被搬到位置 floor((cur_t+1)/2)
                // 注意：执行完“时间 cur_t+1 的操作”后，时间变为 cur_t+1
                cur_t++;
                cur_pos = cur_t / 2; // 这里 cur_t 已经是 next_step
            } else {
                // 如果 cow c 在位置 1..L：
                // 在下一次操作中它会前移 1 格（cur_pos--）。
                // 更进一步：只要它一直在 1..L 范围内，
                // 它就会“每步前移 1”，直到到达队首。
                //
                // 因此我们可以一次性走 steps = cur_pos 步，
                // 让它直接到达队首（位置 0）。
                ll steps = cur_pos;
                // 但如果剩余时间不足 steps，就只能走到 t
                if (cur_t + steps > t) {
                    steps = t - cur_t;
                }
                // 走 steps 步，每步位置减 1
                cur_pos -= steps;
                cur_t += steps;
            }
        }
    }
    // cur_t == t 时，cur_pos 就是答案
    return cur_pos;
}

/*
  query_type_2：给定位置 x 和 time t，问“时间 t 操作执行完之后，位置 x 上是哪头牛”。

  常用递推（用 c(pos, time) 表示答案）：
  - 若 pos > floor(time/2)，该位置不受本步影响，且后半段保持 “牛号=位置”，答案就是 pos
  - 若 pos == floor(time/2)，该位置来自“上一步的队首牛”，即 c(0, time-1)
  - 若 pos < floor(time/2)，则该位置来自上一步的 pos+1，即 c(pos+1, time-1)

  直接递推会 O(t)，所以引入跳步：
  当 pos < floor(time/2) 时，多次执行 pos++, time--，
  一次跳 steps = floor((time - 2*pos)/3)（并保证至少 1），以实现 O(log t)。
*/
ll query_type_2(ll x, ll t) {
    ll cur_t = t;      // 当前递推的时间（从 t 往 0 递推）
    ll cur_pos = x;    // 当前追踪的“位置”
    // 如果问的是队尾位置（pos==t），时间 t 后队尾一定是牛 t（新加入的那头）
    // 这里直接返回 cur_pos（因为牛号=位置=t）
    if (cur_pos == cur_t) return cur_pos;
    while (true) {
        ll L = cur_t / 2; // 当前这一步的分界 floor(cur_t/2)
        // 如果位置在后半段（>L），不会再受递推影响，答案就是该位置编号
        if (cur_pos > L) {
            return cur_pos;
        }
        // 时间递推到 0 时，队列只有牛 0，因此答案为 0（且此时位置只能是 0）
        if (cur_t == 0) return 0;
        // val = cur_t - 2*cur_pos，用来估算可以安全跳多少步
        // steps = floor((cur_t - 2*cur_pos)/3)
        // （对应经典推导：保证跳步过程中一直保持 cur_pos < floor(cur_t/2) 的分支）
        ll val = cur_t - 2 * cur_pos;
        ll steps = val / 3;
        if (steps <= 0) {//直接==0也可以，但是工程上更安全，能兜住意外状态。
            // steps<=0 说明已经非常接近分界，需要“手动走一步”避免卡住
            if (cur_pos == L) {
                // cur_pos == L（也就是 pos == floor(time/2)）：
                // 递推到 c(0, time-1)
                cur_pos = 0;
            } else {
                // cur_pos < L：
                // 递推到 c(cur_pos+1, time-1)，即 pos++
                cur_pos++;
            }
            // 时间递推 time--
            cur_t--;
        } else {
            // 批量跳 steps 步，相当于重复执行 steps 次：
            // cur_pos++，cur_t--
            cur_t -= steps;
            cur_pos += steps;
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int Q;
    if (cin >> Q) {
        while (Q--) {
            ll type, a, b;
            cin >> type >> a >> b;
            if (type == 1) {
                cout << query_type_1(a, b) << "\n";
            } else {
                cout << query_type_2(a, b) << "\n";
            }
        }
    }
    return 0;
}

```

### Problem 3. Sliding Window Summation

🧩 题意：