## USACO 2026 January Contest, Silver

### Problem 1. Lineup Queries

🧩 题意：第0头牛移动到[t/2]处，[t/2]前的每一头牛都往前移一位，每次迭代都在队尾加入t。询问1：牛c在时间t后的位置。询问2.时间t后，位置x上是哪头牛。

🎯 思路：如果某头牛在时间 `t` 之前位于队首，那么它在执行队首移到 t后，会被放到大约 t/2 的位置；要再回到队首，至少还要等它向前“走完”这 t/2步，所以回到队首的时间至少是t+1+t/2。由于 t ≤10^18，因此不能用简单的模拟。

### 📌 Type 1：cow c 在时间 t 后的位置

1. 牛 i 在时间 2i 之前不会动：因为它刚加入时在位置 i，而只有位置 ≤⌊t/2⌋ 的区域会被“前移/插入”影响；当 t<2i 时，⌊t/2⌋<i 它一直不在被影响的前半段里，所以位置恒为 i。
2. 若在某个时刻（执行操作前）它在位置 p，那么在接下来的 p 次操作里，它每次都会往前挪 1 格（因为前半段整体前移），所以 经过 p 步到达队首。
3. 一旦它到达队首，在下一次操作会被直接扔到 ⌊当前时刻/2⌋。

于是我们对单头牛做“循环模拟”：

- 如果剩余时间不够它走到队首：直接返回p−Δ。
- 否则让它走到队首（耗时 p），再执行一次“扔到中间”（耗时 1），位置变成 ⌊cur/2⌋。
   因为“到队首”的次数是对数级，所以总步数是 O(logt)。

### 📌 Type 2：问时间 t 后，位置 x 上是哪头牛

定义 c(p,t) 表示“时间 t 后位置 p 的牛”。可以直接从一步演化推出递推：

- 若 p>⌊t/2⌋，这些位置完全不受当步影响（只是在末尾追加新牛），所以  **c(p,t)=p**。

- 若 p=⌊t/2⌋，这一格正好接收了“上一步的队首牛”，所以
  $$
  c(\lfloor t/2\rfloor, t)=c(0,t-1).
  $$
  
- 若 p<⌊t/2⌋，那么位置 1…⌊t/2⌋ 整体前移一格，所以
  $$
  c(p,t)=c(p+1,t-1).
  $$
  

如果每次只做p←p+1,t←t−1 会变成 O(t)。优化做法是一次跳 Δ步，找一个“保守但足够大”的 且一直满足“在左侧区域”条件。x+k约等于(t-k)/2算出k约等于⌊(t−2p)/3⌋给出：
$$
\Delta=\max\left(1,\left\lfloor\frac{t-2p}{3}\right\rfloor\right).
$$
这样 t 会以常数比例下降，整体仍是 **O(log t)**。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long ll;

/*
  query_type_1是给定 cow c 和 time t，问“时间 t 操作执行完之后，cow c 的位置是多少”。
  - cur_t：当前我们已经模拟到“时间 cur_t 操作执行完之后”的状态
  - cur_pos：此时 cow c 的位置
  返回模拟位置
*/
ll query_type_1(ll c, ll t) {
    // 先把“cow c 加入队列后的状态”当作起点，再向后模拟
    ll cur_t = c;
    ll cur_pos = c;
    while (cur_t < t) {
        // next_step 表示下一次要执行的是“时间 cur_t+1 的操作”
        ll next_step = cur_t + 1;
        // L = floor((cur_t+1)/2)，即下一次操作时，被影响（发生整体前移、并插入队首牛）的区间上界
        // 下一次操作规则：
        //   - 位置 0 的牛被移到 L
        //   - 位置 1..L 的牛整体前移一格（位置减 1）
        //   - 新牛 next_step 加到队尾
        ll L = next_step / 2;
        // 如果 cow c 当前在位置 > L：
        // 那么在下一次操作中，它不在“被整体前移”的区间内，也不会被搬动，
        // 但为了加速，我们尝试“跳过若干步”，直到它可能进入会受影响的前半段。
        if (cur_pos > L) {
            // 经验/推导：当时间达到 2*cur_pos 时，floor(time/2) 会 >= cur_pos，
            // cow c 才可能落入被影响区间
            // 所以 target_time = 2*cur_pos 作为“可能开始受影响的时间点”。
            ll target_time = 2 * cur_pos;
            // 如果这个时间点已经超过查询目标 t，
            // 说明在 [cur_t+1 .. t] 的所有操作中 cow c 都不会受影响，
            // 位置保持 cur_pos 不变，直接返回。
            if (target_time > t) {
                return cur_pos;
            }
            // 否则，我们把 cur_t 尽量跳到 target_time-1，
            // 这样下一轮循环就会处理“时间 target_time 的操作”。
            ll jump_to = target_time - 1;
            if (jump_to > cur_t) {
                cur_t = jump_to;
            } else {
                // 理论上不会太常发生：确保 cur_t 总能前进，避免死循环
                cur_t++;
            }
        } else {
            // 走到这里说明 cow c 在下一次操作时属于“前半段（<=L）”，会受影响。
            // 分两种情况：
            if (cur_pos == 0) {
                // 如果 cow c 恰好在队首（位置 0）：
                // 在下一次操作中它会被搬到位置 floor((cur_t+1)/2)
                // 注意：执行完“时间 cur_t+1 的操作”后，时间变为 cur_t+1
                cur_t++;
                cur_pos = cur_t / 2; // 这里 cur_t 已经是 next_step
            } else {
                // 如果 cow c 在位置 1..L：
                // 在下一次操作中它会前移 1 格（cur_pos--）。
                // 更进一步：只要它一直在 1..L 范围内，
                // 它就会“每步前移 1”，直到到达队首。
                //
                // 因此我们可以一次性走 steps = cur_pos 步，
                // 让它直接到达队首（位置 0）。
                ll steps = cur_pos;
                // 但如果剩余时间不足 steps，就只能走到 t
                if (cur_t + steps > t) {
                    steps = t - cur_t;
                }
                // 走 steps 步，每步位置减 1
                cur_pos -= steps;
                cur_t += steps;
            }
        }
    }
    // cur_t == t 时，cur_pos 就是答案
    return cur_pos;
}

/*
  query_type_2：给定位置 x 和 time t，问“时间 t 操作执行完之后，位置 x 上是哪头牛”。

  常用递推（用 c(pos, time) 表示答案）：
  - 若 pos > floor(time/2)，该位置不受本步影响，且后半段保持 “牛号=位置”，答案就是 pos
  - 若 pos == floor(time/2)，该位置来自“上一步的队首牛”，即 c(0, time-1)
  - 若 pos < floor(time/2)，则该位置来自上一步的 pos+1，即 c(pos+1, time-1)

  直接递推会 O(t)，所以引入跳步：
  当 pos < floor(time/2) 时，多次执行 pos++, time--，
  一次跳 steps = floor((time - 2*pos)/3)（并保证至少 1），以实现 O(log t)。
*/
ll query_type_2(ll x, ll t) {
    ll cur_t = t;      // 当前递推的时间（从 t 往 0 递推）
    ll cur_pos = x;    // 当前追踪的“位置”
    // 如果问的是队尾位置（pos==t），时间 t 后队尾一定是牛 t（新加入的那头）
    // 这里直接返回 cur_pos（因为牛号=位置=t）
    if (cur_pos == cur_t) return cur_pos;
    while (true) {
        ll L = cur_t / 2; // 当前这一步的分界 floor(cur_t/2)
        // 如果位置在后半段（>L），不会再受递推影响，答案就是该位置编号
        if (cur_pos > L) {
            return cur_pos;
        }
        // 时间递推到 0 时，队列只有牛 0，因此答案为 0（且此时位置只能是 0）
        if (cur_t == 0) return 0;
        // val = cur_t - 2*cur_pos，用来估算可以安全跳多少步
        // steps = floor((cur_t - 2*cur_pos)/3)
        // （对应经典推导：保证跳步过程中一直保持 cur_pos < floor(cur_t/2) 的分支）
        ll val = cur_t - 2 * cur_pos;
        ll steps = val / 3;
        if (steps <= 0) {//直接==0也可以，但是工程上更安全，能兜住意外状态。
            // steps<=0 说明已经非常接近分界，需要“手动走一步”避免卡住
            if (cur_pos == L) {
                // cur_pos == L（也就是 pos == floor(time/2)）：
                // 递推到 c(0, time-1)
                cur_pos = 0;
            } else {
                // cur_pos < L：
                // 递推到 c(cur_pos+1, time-1)，即 pos++
                cur_pos++;
            }
            // 时间递推 time--
            cur_t--;
        } else {
            // 批量跳 steps 步，相当于重复执行 steps 次：
            // cur_pos++，cur_t--
            cur_t -= steps;
            cur_pos += steps;
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int Q;
    if (cin >> Q) {
        while (Q--) {
            ll type, a, b;
            cin >> type >> a >> b;
            if (type == 1) {
                cout << query_type_1(a, b) << "\n";
            } else {
                cout << query_type_2(a, b) << "\n";
            }
        }
    }
    return 0;
}

```

### Problem 2. Mooclear Reactor（最大区间覆盖问题）

> 连通块 + 线性表示 + 区间最大覆盖问题

🧩 题意：要给每个 rod 选一个整数 ai。 每条约束是：ax + ay = z。rod i 发电当且仅当 li <= ai <= ri。

目标：在所有约束可满足的前提下，使发电 rod 数量最大；若无解输出 -1。

思路：把等式约束看成图上的关系传播，每条约束 (x, y, z) 表示ax + ay = z把它建成一张无向图：点是变量 a1..aN，边 (x,y) 的权重是 z。关键事实：沿着一条边，如果你知道 ax，就能唯一算出 ay：ay = z - ax。

### Subtask 1：所有约束都是 x = y

此时每条约束形如：

ax + ax = z  ->  2ax = z  ->  ax = z/2

因此：

1. 如果 z 是奇数，那么 z/2 不是整数，直接无解，输出 -1。
2. 如果同一个 x 出现在多条约束里，那么它被要求等于不同的 z/2 也会无解。
3. 否则，每个出现在约束中的 ax 都被“固定”为唯一整数值。

最大化发电数的计算：

- 对被固定的 rod x：它发电当且仅当 lx <= ax <= rx（也就是 lx <= z/2 <= rx）。
- 对没被固定的 rod：没有任何约束限制它，可以直接选 ai = li，让它一定发电。

### Subtask 2：所有约束满足 |x - y| = 1（只连相邻）

图结构变成若干条“链”（path），每个连通块都是一条线。

在一条链里，任选一个起点 x，给 ax 选一个值后，整条链其他点的值都被唯一推出来，因为每次都是：

next = z - current

推着推着会出现交替形式：

ay = c + ax  或  ay = c - ax

也就是 “ay 等于 ax 的正负号再加一个常数”。

于是对每个 y，它发电的条件是：

ly <= ay <= ry

代入 ay = c +/- ax，就会变成对 ax 的一个区间限制，例如：

- 若 ay = c + ax，则 ax 在 [ly - c, ry - c]
- 若 ay = c - ax，则 ax 在 [c - ry, c - ly]

所以每个点 y 都对应一个“ax 的可行区间”，想让尽量多点发电，就要选一个 ax，让它落在最多的这些区间里。

这就变成标准问题：给一堆区间，求最大重叠数。

做法：把每个区间 [L,R] 转成事件 (L,+1), (R+1,-1)，排序扫描求最大前缀和。

### Subtask 3：所有约束满足 |x - y| <= 1（相同或相邻）

这相当于把 Subtask 1 和 Subtask 2 合在一起：

- 当 x = y 时，会直接固定某些点的值（如 Subtask 1）。
- 当 x 和 y 相邻时，形成链式传播（如 Subtask 2）。

对每条链（连通块）：

1. 如果链里没有任何被固定的点：就用 Subtask 2 的“区间最大重叠”方法选最优 ax。
2. 如果链里存在被固定的点：那整条链所有点的值都会被唯一推出来。然后直接统计有多少点落在各自区间里即可。
3. 如果链里有多个固定点，推出来的结果不一致：无解，输出 -1。

````C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <cstdlib>

using namespace std;
using ll = long long;

struct Edge {
    int to;
    ll z;
};

const ll INF = (ll)4e18;

int N, M;
vector<ll> L, R;
vector<vector<Edge>> adj;

vector<int> vis;
vector<ll> c;
vector<int> s; // 1 or -1

// component 状态（DFS 过程中/之后用于判断矛盾与 t 是否被固定）
bool comp_bad;     // 是否发现矛盾（如偶环权值冲突，奇环导致 t 非整数/冲突）
bool comp_fixed;   // 参数 t 是否被固定
ll comp_t_val;     // 若固定，t 的值

// 预处理自环约束 (x=x)
vector<int> has_self_fix;
vector<ll> self_fix_val;

void dfs(int u, vector<int>& comp) {
    comp.push_back(u);
    vis[u] = 1;

    for (auto& e : adj[u]) {
        if (comp_bad) return; // 剪枝

        int v = e.to;
        ll z = e.z;

        if (!vis[v]) {
            // 树边：继续推导
            // 若 a[u] = s[u]*t + c[u]
            // 则 a[v] = z - a[u] = (-s[u])*t + (z - c[u])
            s[v] = -s[u];
            c[v] = z - c[u];
            dfs(v, comp);
        } else {
            // 回边：检查约束是否一致
            // 已有 a[u] = s[u]*t + c[u], a[v] = s[v]*t + c[v]
            // 需要满足 (s[u]*t + c[u]) + (s[v]*t + c[v]) = z

            if (s[v] != s[u]) {
                // 异号（s[v] = -s[u]）：偶环
                // t 项抵消，必须满足 c[u] + c[v] = z
                if (c[u] + c[v] != z) {
                    comp_bad = true;
                }
            } else {
                // 同号（s[v] = s[u]）：奇环
                // (s[u]+s[v])t + c[u]+c[v] = z
                // 2*s[u]*t = z - c[u] - c[v]
                ll rhs = z - c[u] - c[v];

                if (llabs(rhs) % 2 != 0) {
                    comp_bad = true; // t 不是整数
                } else {
                    // t = (rhs/2) / s[u]；因 s[u] 是 ±1，除法等价乘法
                    ll calculated_t = (rhs / 2) * (ll)s[u];

                    if (comp_fixed) {
                        if (comp_t_val != calculated_t) comp_bad = true;
                    } else {
                        comp_fixed = true;
                        comp_t_val = calculated_t;
                    }
                }
            }
        }
    }
}

void solve() {
    cin >> N >> M;

    L.assign(N + 1, 0);
    R.assign(N + 1, 0);
    for (int i = 1; i <= N; i++) cin >> L[i];
    for (int i = 1; i <= N; i++) cin >> R[i];

    adj.assign(N + 1, {});
    has_self_fix.assign(N + 1, 0);
    self_fix_val.assign(N + 1, 0);

    bool global_possible = true;

    // 读入约束：先处理 x==y 的自环约束（直接固定 a[x]=z/2）
    for (int i = 0; i < M; i++) {
        int x, y;
        ll z;
        cin >> x >> y >> z;

        if (x == y) {
            // 自环：2*a[x] = z
            if (z % 2 != 0) {
                global_possible = false;
            } else {
                ll val = z / 2;
                if (has_self_fix[x] && self_fix_val[x] != val) {
                    global_possible = false;
                }
                has_self_fix[x] = 1;
                self_fix_val[x] = val;
            }
        } else {
            // 普通边：a[x] + a[y] = z
            adj[x].push_back({y, z});
            adj[y].push_back({x, z});
        }
    }

    if (!global_possible) {
        cout << -1 << '\n';
        return;
    }

    vis.assign(N + 1, 0);
    c.assign(N + 1, 0);
    s.assign(N + 1, 0);

    ll total_ans = 0;

    for (int i = 1; i <= N; i++) {
        if (vis[i]) continue;

        // 初始化该连通块的状态
        s[i] = 1;   // 设 root 的 s=1, c=0，即 a_root = t
        c[i] = 0;
        comp_bad = false;
        comp_fixed = false;
        comp_t_val = 0;

        vector<int> comp;

        // 1) DFS：建立 a[u] = s[u]*t + c[u]，并检查环约束
        dfs(i, comp);

        if (comp_bad) {
            global_possible = false;
            break;
        }

        // 2) 把“自环固定值”并入该连通块（可能进一步固定 t 或产生冲突）
        for (int u : comp) {
            if (has_self_fix[u]) {
                // a[u] = s[u]*t + c[u] = self_fix_val[u]
                // => t = (self_fix_val[u] - c[u]) / s[u]，s[u]=±1 => 乘即可
                ll required_t = (self_fix_val[u] - c[u]) * (ll)s[u];

                if (comp_fixed) {
                    if (comp_t_val != required_t) {
                        comp_bad = true;
                        break;
                    }
                } else {
                    comp_fixed = true;
                    comp_t_val = required_t;
                }
            }
        }

        if (comp_bad) {
            global_possible = false;
            break;
        }

        // 3) 计算该连通块能达到的最大发电数
        if (comp_fixed) {
            // Case A：t 被固定，直接算每个点实际 a[u] 是否落在 [L[u],R[u]]
            int cnt = 0;
            for (int u : comp) {
                ll val = (ll)s[u] * comp_t_val + c[u];
                if (val >= L[u] && val <= R[u]) cnt++;
            }
            total_ans += cnt;
        } else {
            // Case B：t 自由，转成对 t 的区间覆盖最大值问题
            vector<pair<ll, int>> events;

            for (int u : comp) {
                // 约束：L[u] <= s[u]*t + c[u] <= R[u]
                ll lo, hi;
                if (s[u] == 1) {
                    // L - c <= t <= R - c
                    lo = L[u] - c[u];
                    hi = R[u] - c[u];
                } else {
                    // L <= -t + c <= R  ->  c - R <= t <= c - L
                    lo = c[u] - R[u];
                    hi = c[u] - L[u];
                }

                if (lo <= hi) {
                    // 区间 [lo, hi]：差分事件
                    events.push_back({lo, 1});
                    events.push_back({hi + 1, -1});
                }
            }

            sort(events.begin(), events.end());

            int max_overlap = 0;
            int cur_overlap = 0;
            for (auto& ev : events) {
                cur_overlap += ev.second;
                if (cur_overlap > max_overlap) {
                    max_overlap = cur_overlap;
                }
            }

            total_ans += max_overlap;
        }
    }

    if (!global_possible) cout << -1 << '\n';
    else cout << total_ans << '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    if (cin >> T) {
        while (T--) {
            solve();
        }
    }
    return 0;
}
````

### 扫描线 / 差分概念：

有 4 根 rod，它们在某个连通块里都能写成：

ai = s[i] * t + c[i]   （t 是整数，可自由选）

给定：

- rod1: s= 1, c=0, 区间 [1, 4]
- rod2: s=-1, c=6, 区间 [2, 5]
- rod3: s= 1, c=1, 区间 [3, 7]
- rod4: s=-1, c=3, 区间 [0, 2]

问：选一个整数 t，让发电 rod 数最多。发电条件是 Li <= ai <= Ri。

#### 第一步：把每个 rod 的发电条件转成 “t 的区间”

### rod1: a1 = 1*t + 0

要 [1,4] 内发电：
 1 <= t <= 4
 所以 t 的区间是 [1, 4]

### rod2: a2 = -t + 6

要 [2,5] 内发电：
 2 <= -t + 6 <= 5

分别化简：

- 2 <= -t + 6  ->  -t >= -4  ->  t <= 4
- -t + 6 <= 5  ->  -t <= -1  ->  t >= 1

所以 t 的区间是 [1, 4]

### rod3: a3 = t + 1

要 [3,7] 内发电：
 3 <= t + 1 <= 7
 t 的区间是 [2, 6]

### rod4: a4 = -t + 3

要 [0,2] 内发电：
 0 <= -t + 3 <= 2

化简：

- 0 <= -t + 3  ->  -t >= -3 -> t <= 3
- -t + 3 <= 2  ->  -t <= -1 -> t >= 1

所以 t 的区间是 [1, 3]

总结：每个 rod 发电等价于 t 落在下面区间

- rod1: [1,4]
- rod2: [1,4]
- rod3: [2,6]
- rod4: [1,3]

问题变成：选一个整数 t，让 t 落在最多区间里。

#### 第二步：用差分事件表示区间

对每个闭区间 [L, R]，加入事件：

- (L, +1)
- (R+1, -1)

生成事件：

- [1,4] -> (1,+1), (5,-1)   （rod1）
- [1,4] -> (1,+1), (5,-1)   （rod2）
- [2,6] -> (2,+1), (7,-1)   （rod3）
- [1,3] -> (1,+1), (4,-1)   （rod4）

把所有事件列出来：

(1,+1), (5,-1)
 (1,+1), (5,-1)
 (2,+1), (7,-1)
 (1,+1), (4,-1)

#### 第三步：排序并扫描（扫描线）

按位置排序：

- (1, +1)
- (1, +1)
- (1, +1)
- (2, +1)
- (4, -1)
- (5, -1)
- (5, -1)
- (7, -1)

从小到大累加 cur：

- 位置 1：cur = 1
- 位置 1：cur = 2
- 位置 1：cur = 3   -> max = 3
- 位置 2：cur = 4   -> max = 4
- 位置 4：cur = 3
- 位置 5：cur = 2
- 位置 5：cur = 1
- 位置 7：cur = 0

所以最大覆盖数是 4。

***

### Problem 3. Sliding Window Summation

🧩 题意：Bessie 有一个隐藏的二进制字符串 b1 b2 … bN（其中 1 ≤ N ≤ 2×10^5）。

你对这个字符串 b 唯一已知的信息，是另一个二进制字符串 r1 r2 … r(N−K+1)（其中 1 ≤ K ≤ N）。这里的 ri 的含义是：

- 取 b 中从位置 i 开始、长度为 K 的连续子串（窗口）；
- 统计这个窗口里“1”的个数；
- 用这个“1”的个数除以 2，取余数（也就是看它是奇数还是偶数）；
- 这个余数就是 ri。

换句话说：
ri = 0 表示第 i 个长度为 K 的窗口里 1 的数量是偶数；
ri = 1 表示第 i 个长度为 K 的窗口里 1 的数量是奇数。

题目要求：输出 Bessie 隐藏字符串 b 中，“1”的总数可能的最小值和最大值。

🎯 思路：构造题，把滑窗奇偶变成 **按模 K 的链 + 2 状态 DP**。
$$
r_i \equiv \sum_{j=i}^{i+K-1} b_j \pmod 2 \qquad (1\le i\le N-K+1)
$$
看相邻两个窗口：

- 第 i 个：bi+bi+1+⋯+bi+K−1
- 第 i+1 个：bi+1+⋯+bi+K

$$
r_i \oplus r_{i+1} = b_i \oplus b_{i+K}\qquad (1\le i\le N-K)
$$

由于ri已知，令
$$
d_i = r_i \oplus r_{i+1}
$$

$$
b_{i+K} = b_i \oplus d_i
$$

**解释：** di 可以理解从位置 i 跳到 i+K 时，要不要翻转。

>  按 i mod K 分成 K 条链：每条链由链头决定

- 链 1：1, 1+K, 1+2K,...
- 链 2：2, 2+K,...
- …
- 链 K：K, 2K,...

$$
b_{s+tK} = b_s \oplus 沿途的d
$$


定义一个ti，表示从链头到i是否翻转（XOR 累积），显然链头的ti=0，当i>k时：
$$
t_i = t_{i-K}\oplus d_{i-K}
$$
于是对所有的i都可以
$$
b_i = x_{((i-1)\bmod K)+1} \oplus t_i
$$
所以串b是有K个链头x1..xK 决定；而 ti 可根据di线性算出。

因此，若链头 X_s=0，则 b_i=t_i，这条链1数取决于t_i=1的个数（one_s）。若链头 X_s=1，则整条链翻转，1数等于链长减去one_s。

所以对链的贡献是二选一：

- 选 0：`cost0 = one_s`
- 选 1：`cost1 = len_s - one_s`

第一个窗口就是 b_1..b_K，但这正是链头：
$$
r_1 = b_1\oplus b_2\oplus \dots \oplus b_K
     = x_1\oplus x_2\oplus \dots \oplus x_K
$$
因此我们要

- 最小化 / 最大化 ∑s cost(Xs)

- $$
  x_1\oplus x_2\oplus \dots \oplus x_K     = r_1
  $$


这是经典 **2 状态 DP（按 XOR 奇偶）**：

令 `dpMin[p]`：处理到某些链后，链头 XOR 为 0/1 时最小 1 数。
 转移处理第 s 条链：

- 选 Xs=0：不需要翻转，加 `cost0`
- 选 Xs=1：若翻转，加 `cost1`

同理 `dpMax` 求最大。

```c++
#include<bits/stdc++.h>
using namespace std;
/*
  - b[1..N] 是隐藏二进制串
  - 给 r[1..N-K+1]：r_i = (b_i + ... + b_{i+K-1}) mod 2
  - 求满足所有 r 的 b 中，1 的最小数量和最大数量
  核心推导：
  1) 相邻窗口相消：d_i = r_i XOR r_{i+1} = b_i XOR b_{i+K}
     => b_{i+K} = b_i XOR d_i
  2) 因为只连 i 与 i+K，所以按 i mod K 分成 K 条链
  3) 每条链只剩一个自由变量：链头 x_s (s=1..K)，其他位置 = x_s XOR t_i
     其中 t_i 是沿链累计 XOR 的“翻转奇偶”，只由 d 决定（即只由 r 决定）
  4) 第一窗口给全局约束：x_1 XOR ... XOR x_K = r_1
  5) 对每条链，若链头取 0/1，链上 1 的个数分别为 two choices
     用 DP 或贪心+修正可算 min/max
*/
void solve() {
    int N, K;
    if (!(cin >> N >> K)) return;
    string R;
    cin >> R; // R 长度 = N-K+1
    // chains 存每条链的两种“代价”（链头选 0/1 时该链贡献的 1 个数）
    // 这里用 pair<int,int>存两种代价
    // cost_start_0 = p.first, cost_start_1 = p.second
    // 注意：你 push_back({cnt1,cnt0})，所以：
    //   p.first  = cnt1  (链头取 0 时 1 的数量)
    //   p.second = cnt0  (链头取 1 时 1 的数量)
    vector<pair<int, int>> chains; 
    chains.reserve(K);
    /*
      rem = 0..K-1 表示一条链：
      - 0-index 下，链 rem 包含位置 rem, rem+K, rem+2K,...（对应 b 的下标是 1+rem, 1+rem+K,...）
      这等价于理论里的 “i mod K” 分链。
    */
    for (int rem = 0; rem < K; ++rem) {
        int cnt0 = 0; // 该链上 t 值为 0 的位置数
        int cnt1 = 0; // 该链上 t 值为 1 的位置数
        
        int curr = rem;          // 当前在这条链上的位置（0-index）
        int current_rel_val = 0; // 这就是 t 值：从链头走到 curr 的累计 XOR（翻转奇偶）
                                 // 链头位置 t=0

        // 链头：t=0，因此把链头计入 cnt0
        if (current_rel_val == 0) cnt0++; else cnt1++;
        
        /*
          沿链向下走：curr -> curr+K -> curr+2K ...
          由推导：b_{i+K} = b_i XOR d_i，其中 d_i = r_i XOR r_{i+1}
          
          这里的下标要注意：curr 表示 0-index 的 i-1，
          那么对应 d_{i} 用 R[curr] XOR R[curr+1]（因为 R 存的是 r）
          
          diff = (R[curr] - '0') XOR (R[curr+1] - '0')
               = r_{curr+1} XOR r_{curr+2}
               = d_{curr+1}
          这就是从位置 i 到 i+K 是否翻转（1=翻转，0=不翻转）。
        */
        while (curr + K < N) {
            int diff = (R[curr] - '0') ^ (R[curr+1] - '0'); // d 值（是否翻转）
            current_rel_val ^= diff; // t 累计：t_{next} = t_{curr} XOR d

            // 统计这条链上 t=0 和 t=1 的个数
            if (current_rel_val == 0) cnt0++; else cnt1++;
            
            curr += K;
        }

        /*
          对这条链：
          - 若链头 x=0，则 b = t，因此 1 的个数 = cnt1
          - 若链头 x=1，则 b = 1 XOR t（整链翻转），1 的个数 = cnt0
          所以保存 {cnt1, cnt0} 作为两种选择的代价。
        */
        chains.push_back({cnt1, cnt0});
    }

    // 第一窗口约束：x_1 XOR x_2 XOR ... XOR x_K = r_1
    // 这里 R[0] 就是 r_1
    int target_parity = R[0] - '0';

    /*
      接下来求最小值 min_total。
      标准做法是 2 状态 DP（按 XOR parity）。
      你这里用的是“先每条链取更小的代价”作为基础，
      并记录当前选法导致的链头 XOR（current_parity），
      如果 XOR 不满足 target，就用最小代价差 min_diff 来修正一次。

      这相当于：
      - 每条链有两种成本 cost0/cost1，对应选择 x_s=0 或 x_s=1。
      - 你先独立选最便宜的那种，得到一个总和与一个 XOR parity。
      - 若 parity 不对，只需要把其中一条链从便宜切换到贵，
        代价增加 |cost0-cost1|，选差最小的一条即可修正 parity。
    */
    long long min_total = 0;
    int current_parity = 0;   // 当前所选链头的 XOR（0/1）
    int min_diff = 1e9 + 7;   // 记录最小的 |cost0-cost1|，用于修正 parity

    for (const auto& p : chains) {
        int cost_start_0 = p.first;  // 链头 x=0 时该链 1 的数量（=cnt1）
        int cost_start_1 = p.second; // 链头 x=1 时该链 1 的数量（=cnt0）
        
        // 先贪心选更小的成本
        if (cost_start_0 < cost_start_1) {
            min_total += cost_start_0; // 选 x=0
            // current_parity 不变
        } else {
            min_total += cost_start_1; // 选 x=1
            current_parity ^= 1;       // 因为选了 x=1，链头 XOR 翻转
        }

        // 如果后续需要修正 parity，就翻转某条链的选择，
        // 代价会改变 |cost0-cost1|，取最小的那条最好
        min_diff = min(min_diff, abs(cost_start_0 - cost_start_1));
    }

    // 如果当前链头 XOR != r1，就必须“翻转其中一条链的选择”来改变 parity
    // 翻转一次会使 XOR 翻转 1，同时成本增加最小差值 min_diff
    if (current_parity != target_parity) {
        min_total += min_diff;
    }

    /*
      再求最大值 max_total。
      类似逻辑：先每条链取更大的代价，
      若最后 parity 不对，需要翻转一条链，且会损失 |cost0-cost1|，
      因此应选损失最小的一条（同样用 min_diff）。
    */
    long long max_total = 0;
    current_parity = 0;
    min_diff = 1e9 + 7;

    for (const auto& p : chains) {
        int cost_start_0 = p.first;
        int cost_start_1 = p.second;
        
        // 贪心选更大的成本（为了最大化 1 的数量）
        if (cost_start_0 > cost_start_1) {
            max_total += cost_start_0; // 选 x=0
            // parity 不变
        } else {
            max_total += cost_start_1; // 选 x=1
            current_parity ^= 1;       // 选 x=1 会让链头 XOR 翻转
        }

        // 若需要修正 parity，翻转一条链的选择会减少 |cost0-cost1|，
        // 因此取最小差值的链损失最小
        min_diff = min(min_diff, abs(cost_start_0 - cost_start_1));
    }

    // 若 parity 不满足 r1，需要翻转一条链，总代价会减少 min_diff
    if (current_parity != target_parity) {
        max_total -= min_diff;
    }

    cout << min_total << " " << max_total << "\n";
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int T;
    if (cin >> T) {
        while (T--) {
            solve();
        }
    }
    return 0;
}
```
