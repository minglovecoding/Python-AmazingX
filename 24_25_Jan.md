## USACO 2025 January Contest, Bronze

### Problem 1. Astral Superposition

题意： 一个N✖️N方格，每个方格可能会有一个星星。经过变化后，原来的星星可能会消失，也可能会向右移动A、再向下移动B。如果星星移动出界或消失，那么就不会出现在第二张照片。现在两张照片重叠，如果没有星星，显示White。如果一个星星，显示Gray，如果两个星星，显示Black。现在给出重叠后的影像，以及A，B值，求第一张图的最小星星数。

思路：![idea](/Users/zhoumingzhao/Desktop/Python-AmazingX/images/6.png)

```Python
WGB={
    'W':0,
    'G':1,
    'B':2,
}
def _case():
    N,A,B=[int(x) for x in input().split()]
    map2=[[WGB[x] for x in input()] for _ in range(N)]
    map1=[[0 for _ in range(N)] for _ in range(N)]
   
    for i in range(N):
        for j in range(N):
            if map2[i][j]==2:
                map1[i][j]=1
                if i<B or j<A:
                    print(-1)
                    return 
                if map2[i-B][j-A]==0:
                    print(-1)
                    return
                map1[i-B][j-A]=1
    
    for i in range(N):
        for j in range(N):
            if map2[i][j]==1:
                if map1[i][j]==1:
                    continue
                if i<B or j<A:
                    map1[i][j]=1
                    continue
                if map1[i-B][j-A]==1:
                    continue
                map1[i][j]=1

    print(sum(sum(x) for x in map1))

T=int(input())
while T:
    T-=1
    _case()
```

### Problem 2. It's Mooin' Time II

题意：a2,…,aNa1,a2,…,aN，哞哞叫abb。

```python
N=int(input())
nums=[int(x) for x in input().split()]

left=[0]*(N+1)
right=[0]*(N+1)
_left=0
ans=0

for i in range(N):
    right[nums[i]]+=1

for i in range(N):
    if right[nums[i]]==2:
        ans+=_left-(left[nums[i]]>0)
    right[nums[i]]-=1
    _left+=left[nums[i]]==0
    left[nums[i]]+=1

print(ans)

```

### Problem 3. Cow Checkups

题意：N头牛的排列顺序是a1,a2,…,aN，医生需每头牛与其对应的b1,b2,…,bN相同才为其医治。输出N+1行，每行使得 i−1 头奶牛被检查的操作数量。

思路：遍历每头牛，以奇数或偶数为底向两边扩散。

```python
def main():
    n = int(input())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))

    same=sum(1 for i in range(n) if A[i]==B[i])
    ans=[0]*(n+1)

    def expand(l,r):
        nonlocal same
        _same=same
        while l>=0 and r<n:
            _same-=(A[l]==B[l])+(A[r]==B[r])
            _same+=(A[l]==B[r])+(A[r]==B[l])
            ans[_same]+=1
            l-=1
            r+=1

    for mid in range(n):
        expand(mid,mid)
        expand(mid,mid+1)
    
    for res in ans:
        print(res)

if __name__ == "__main__":
    main()
```

