## USACO 2024 January Contest, Silver

### Problem 2. Potion Farming

## 🧩 一、题目回顾

我们有一棵 $N$ 个节点的树，每个节点是一个“房间”。

- 一共要进行若干次遍历（Traversal），每次从节点 1 出发。
- 目标 1️⃣：最少遍历次数能覆盖整棵树（即所有房间至少访问一次）。
- 目标 2️⃣：在满足目标 1 的前提下，**拾取最多药水**。

每次遍历前，系统会在一个节点 `p[i]` 生成药水（共 N 次）。

------

## 🚩 二、结构分析

树的结构性质：

- 每次 traversal 是从根 `1` 出发到任意节点的简单路径。
- 一次 traversal 可以覆盖一条分支，但无法跨越不同分支。
- 因此：
   **最少遍历次数 = 树中叶子节点数。**

------

## 🧠 三、算法核心思想

这题的思路是**用两次 DFS + 子树叶子计数 + 剩余容量限制**完成。

整个算法结构：

------

### Step 1️⃣：统计每个节点的叶子数 `numLeaves[u]`

用一个 DFS：

```c++
int countLeaves(int cur, int par)
```

递归统计每个节点子树的叶子数量。

- 若当前节点是叶子（无子节点或唯一子节点是父节点），`numLeaves[cur] = 1`。

- 否则：
  $$
  numLeaves[cur] = \sum_{v \in children(cur)} numLeaves[v]
  $$

------

### Step 2️⃣：前若干轮药水分布

由于最少 traversal 数量 = 叶子数，
 所以我们只关注前 `leaves` 次药水出现的位置（后面的药水没机会拾取）。

```c++
for (i = 0; i < leaves; i++)
    modpots[pots[i]]++;
```

这里 `modpots[u]` 表示在“药水可用的次数内”，节点 `u` 出现的药水数量。

------

### Step 3️⃣：计算最大可收集药水数 `countPotions()`

再进行一次 DFS：

```c++
int countPotions(int cur, int par, vector<int>& modpots)
```

逻辑：

1. 先递归求所有子树的药水总和：

   ```c++
   sum += countPotions(v, cur, modpots);
   ```

2. 加上当前节点的药水：

   ```c++
   sum += modpots[cur];
   ```

3. 但当前节点最多能通过它的叶子分支“拿走”这些药水：

   ```c++
   return min(sum, numLeaves[cur]);
   ```

------

### 🧩 思维解释

- 每个节点能“运输”的药水数受限于它的子树能派出的 traversal 数量；
- 每个叶子代表一条可用路径，路径能带回 1 个药水；
- 所以每个节点能“接收”的药水数上限 = 该节点子树的叶子数。

换句话说：

> 我们自底向上地“汇总药水”，但每个节点的流量被 `numLeaves[cur]` 限制。

这其实是一个**“树上容量限制的累加问题”**。

------

## ✅ 四、完整算法流程总结

| 步骤 | 含义                             | 实现                           |
| ---- | -------------------------------- | ------------------------------ |
| 1️⃣    | DFS1 统计每个节点子树叶子数量    | `countLeaves()`                |
| 2️⃣    | 计算总叶子数（=最少 traversal）  | DFS 累加                       |
| 3️⃣    | 前 `leaves` 个药水作为可收集候选 | `modpots[pots[i]]++`           |
| 4️⃣    | DFS2 自底向上计算能收集的药水数  | `countPotions()`               |
| 5️⃣    | 最终答案输出根节点结果           | `countPotions(0, -1, modpots)` |

------

## 🧮 五、复杂度分析

| 操作                   | 复杂度   |
| ---------------------- | -------- |
| 构建图                 | O(N)     |
| DFS 统计叶子           | O(N)     |
| 统计前 `leaves` 个药水 | O(N)     |
| DFS 计算答案           | O(N)     |
| **总计**               | **O(N)** |
| 空间复杂度             | **O(N)** |

------

## ✅ 六、样例解析

输入：

```c++
5
5 4 3 2 1
1 2
1 3
3 4
3 5
```

树形结构：

```c++
    1
   / \
  2   3
     / \
    4   5
```

- 叶子节点：2、4、5 → `leaves = 3`
- 前 3 瓶药水：出现在 5、4、3
   → `modpots[4]=1, modpots[5]=1, modpots[3]=1`
- 自底向上：
  - 4 的叶子数=1，药水=1 → min(1,1)=1
  - 5 的叶子数=1，药水=1 → min(1,1)=1
  - 3 的子树叶子数=2，药水数(子树)=1+1+modpots[3]=3 → min(3,2)=2
  - 1 的总叶子数=3，药水数(子树)=2+1(modpots[1]=0+叶子2)=3 → min(3,3)=3

→ 根节点答案 = **2**（表示最多可收集 2 瓶药水）。

```c++
#include <bits/stdc++.h>
using namespace std;

/*
  Farming Potions on a Tree
  -------------------------
  主思路：
  1. 计算叶子数 = 最少 traversal 数。
  2. 每个叶子对应一条独立路径（1 → leaf）。
  3. 倒序遍历 N 轮药水出现顺序，从后往前贪心匹配。
     如果药水所在分支还没访问过，就安排这次 traversal，
     并计入一个拾药水。
  4. 最后输出拾药水的最大数量。
*/

const int MAXN = 100005;
vector<int> adj[MAXN];
int parent[MAXN];
int degree_[MAXN];
int p[MAXN];
bool visited[MAXN]; // 标记该分支（叶子）是否已被访问

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;
    for (int i = 1; i <= N; i++) cin >> p[i];

    for (int i = 1; i < N; i++) {
        int a, b;
        cin >> a >> b;
        adj[a].push_back(b);
        adj[b].push_back(a);
        degree_[a]++;
        degree_[b]++;
    }

    // 1️⃣ BFS 预处理父节点 (root = 1)
    queue<int> q;
    q.push(1);
    parent[1] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : adj[u]) {
            if (v == parent[u]) continue;
            parent[v] = u;
            q.push(v);
        }
    }

    // 2️⃣ 找所有叶子节点（度数 == 1 且非根）
    unordered_set<int> leaves;
    for (int i = 2; i <= N; i++) {
        if (degree_[i] == 1)
            leaves.insert(i);
    }

    // 3️⃣ 倒序贪心：从后往前扫描药水
    int potions = 0;
    unordered_set<int> usedBranch; // 已经安排过 traversal 的分支（叶子方向）

    for (int i = N; i >= 1; i--) {
        int node = p[i];
        // 从 node 一直往上走，找到对应的“叶子方向”
        // （即：沿父链往上直到到达一个叶子或根）
        int cur = node;
        while (cur != 0 && leaves.find(cur) == leaves.end()) {
            cur = parent[cur];
        }
        if (cur == 0) continue; // 到根也没找到叶子方向

        if (!usedBranch.count(cur)) {
            usedBranch.insert(cur);
            potions++;
        }

        // 如果所有叶子都访问完了，可以提前停止
        if ((int)usedBranch.size() == (int)leaves.size()) break;
    }

    cout << potions << "\n";
    return 0;
}

```

