## 🎒 4. 经典模型 II：背包 DP（必会）

##### 4.1 0-1 背包

 给定容量为 `W` 的背包，n 件物品，每件有重量 `w[i]` 和价值 `v[i]`。
 要求在不超过容量的情况下，价值最大。

### ✅ 状态定义

```
dp[w] = 容量为 w 时的最大价值
```

------

### ✅ 状态转移方程

$$
dp[w] = \max(dp[w], dp[w - weight[i]] + value[i])
$$

但注意顺序要 **倒序枚举 w**，否则一个物品可能被重复使用。

------

### ✅ 为什么要倒序？

- 因为每个物品只能用一次；
- 如果正序，会导致同一个物品在一次循环内被多次使用（相当于完全背包了）。

------

### 💻 代码模板

```c++
int n, W;
cin >> n >> W;
vector<int> w(n+1), v(n+1);
for (int i = 1; i <= n; i++) cin >> w[i] >> v[i];
vector<int> dp(W + 1, 0);
for (int i = 1; i <= n; i++) {
    for (int j = W; j >= w[i]; j--) {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
cout << dp[W];
```

### 4.2 完全背包 

> 每个物品可以选无限次（类似“硬币问题”）。

### ✅ 状态定义

```c++
dp[w] = 容量为 w 时的最大价值
```

### ✅ 转移方程

$$
dp[w] = \max(dp[w], dp[w - weight[i]] + value[i])
$$

与 0-1 背包几乎相同，但**枚举顺序不同**：

> 完全背包使用 **正序** 遍历 w。

### 💻 代码模板

```c++
for (int i = 1; i <= n; i++) {
    for (int j = w[i]; j <= W; j++) { // 正序遍历
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
```

### 4.3 多重背包

> 每个物品有“数量限制” `count[i]`。

### ✅ 思路一：朴素枚举（复杂度较高）

直接在内层循环中枚举数量：

```c++
for (int i = 1; i <= n; i++) {
    for (int j = W; j >= w[i]; j--) {
        for (int k = 1; k <= cnt[i] && k*w[i] <= j; k++) {
            dp[j] = max(dp[j], dp[j - k*w[i]] + k*v[i]);
        }
    }
}
```

### ✅ 思路二：二进制拆分优化（Binary Optimization）

假设有一个物品：

```c++
重量 w = 2
价值 v = 3
数量 c = 13
```

这意味着你可以选 0~13 个这样的物品。

现在我们用 **二进制拆分**：

```c++
13 = 1 + 2 + 4 + 6
```

于是我们可以生成 4 个「新物品」，把 `cnt[i]` 拆成若干个 0-1 物品。这样问题就变成了**若干个 0-1 背包问题**。

我们把这 4 件新物品放进普通 0-1 背包算法里，每件物品只能选 0 或 1 次。

### 💻 代码模板

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, W;
    cin >> n >> W;
    vector<int> w(n + 1), v(n + 1), c(n + 1);
    for (int i = 1; i <= n; i++)
        cin >> w[i] >> v[i] >> c[i];

    // step 1: 二进制拆分
    vector<pair<int,int>> items; // (weight, value)
    for (int i = 1; i <= n; i++) {
        int num = c[i], k = 1;
        while (num > 0) {
            int use = min(k, num);
            items.push_back({w[i] * use, v[i] * use});
            num -= use;
            k <<= 1;
        }
    }

    // step 2: 0-1 背包
    vector<int> dp(W + 1, 0);
    for (auto [wt, val] : items) {
        for (int j = W; j >= wt; j--) {
            dp[j] = max(dp[j], dp[j - wt] + val);
        }
    }

    cout << dp[W] << "\n";
}

```

### 4.4、体积/费用多维背包（Multi-dimensional Knapsack）

> 有多个约束维度，比如：
>
> - 容量（重量限制）
> - 时间（加工时间）
> - 资金（成本）

### ✅ 状态定义

例如：两个限制（重量 W、时间 T）
$$
dp[w][t] = 不超过重量 w 和时间 t 时的最大价值
$$

------

### ✅ 转移方程

$$
dp[w][t] = \max(dp[w][t], dp[w - weight[i]][t - time[i]] + value[i])
$$

------

### 💻 代码模板

```c++
int W, T, n;
cin >> n >> W >> T;
vector<int> w(n+1), t(n+1), v(n+1);
for (int i = 1; i <= n; i++) cin >> w[i] >> t[i] >> v[i];

vector<vector<int>> dp(W+1, vector<int>(T+1, 0));

for (int i = 1; i <= n; i++) {
    for (int ww = W; ww >= w[i]; ww--) {
        for (int tt = T; tt >= t[i]; tt--) {
            dp[ww][tt] = max(dp[ww][tt],
                             dp[ww - w[i]][tt - t[i]] + v[i]);
        }
    }
}
cout << dp[W][T];
```

------

## 🧩 5. 经典模型 III：区间 DP

- 场景：括号匹配、石子合并、凸多边形三角剖分。
- 通式：`dp[l][r] = min_{k∈(l,r)} dp[l][k] + dp[k+1][r] + cost(l,r,k)`
- 计算顺序：按区间长度 `len` 从小到大。

**例：石子合并**

- `sum[i]` 为前缀和，`cost = sum[r]-sum[l-1]`
- `O(n^3)`；若满足**四边形不等式**，可用 **Knuth/Divide & Conquer** 优化到 `O(n^2)`。

------

## 🧩 6. 经典模型 IV：树上 DP

- **树的直径**、**最大独立集**、**重心**、**树形背包**。
- 常见套路：树形 `dfs(u,fa)`，子树合并时注意转移顺序与临时数组。

**例：树的最大独立集（无相邻点同时选）**

- `dp[u][0/1]`：u 不选/选的最大点权
- 转移：`dp[u][1] = val[u] + Σ dp[v][0]`，`dp[u][0] = Σ max(dp[v][0], dp[v][1])`。

------

## 🧩 7. 经典模型 V：图上 DP（DAG）

- 在 DAG 上按拓扑序进行转移（最长路/计数路径）。
- 也可作为“序列 DP 的广义版”。

------

## 🧩 8. 经典模型 VI：数位 DP（Digit DP）

- 问题：统计区间 [0..N] 中满足某性质的整数个数。
- 状态：`f[pos][tight][lead][...属性...]`
- 细节：处理**前导零**与**上界约束 tight**；通常 `O(位数 * 状态数 * 备选数字)`。

------

## 🧩 9. 经典模型 VII：状压 DP（Bitmask）

- 适用：`n ≤ 20~25` 的子集枚举类，如**TSP**、**分配问题**、**最大团近似**。
- 例（TSP 最短路）：`dp[mask][u] = 访问过 mask，当前在 u 的最短路`，转移枚举下一个点。

------

## 🧩 10. 常见优化

### 10.1 空间优化（滚动数组）

- 条件：`f[i]` 仅依赖 `f[i-1]`；注意遍历方向防止“新值污染旧值”。

### 10.2 单调队列优化（Convex/Monotone Queue）

- 例：`dp[i] = min(dp[i-1]) + cost(i)` + **窗口限制**；或**斜率优化**对应 `w[i]` 单调。

### 10.3 斜率优化（Convex Hull Trick, CHT）

- 形式：`dp[i] = min_j (m_j * x_i + b_j)`，维护下凸包；在线/离线两种实现。

### 10.4 分治优化

- 形式：`dp[l..r]` 的决策点 `opt[l..r]` 单调，递归分治求最优决策，复杂度从 `O(n^2)` 降至 `O(n log n)`。

### 10.5 四边形不等式（Knuth 优化）

- 适用形如区间合并的 DP，需满足 `opt[l][r-1] ≤ opt[l][r] ≤ opt[l+1][r]`。

### 10.6 Bitset 加速

- 如 0-1 背包可用位运算将 `O(nW)` 降为 `O(W/word_size * n)`，或求可达和集合。

------

## 🧩 11. 复杂度评估 & 迁移思维

- **状态数 × 转移代价 = 总复杂度**；先减状态，再减转移。
- 当 `n, m, W` 较大：考虑**近似/期望 DP**、**分层图**、**混合贪心**、**启发式搜索**。



------

## 13. 课堂示例 A：0-1 背包（滚动一维）

**题意**：容量 `W`，`n` 件物品 `(w_i, v_i)`，求最大价值。
 **状态**：`dp[w]`
 **初始化**：`dp[0]=0，其余 -inf`（或 0 取“不能超过容量”的意义）
 **转移**：`for i in items: for w=W..w_i: dp[w] = max(dp[w], dp[w-w_i]+v_i)`
 **注意**：倒序遍历 `w`，防重复使用。

------

## 14. 课堂示例 B：区间石子合并（Knuth 条件）

**题意**：n 堆石子环/链合并成一堆，费用为区间和。
 **状态**：`dp[l][r]`
 **转移**：`dp[l][r] = min_k dp[l][k]+dp[k+1][r]+sum(l,r)`
 **优化**：若满足四边形不等式，`O(n^2)` 实现；否则 `O(n^3)`。

------

## 15. 课堂示例 C：树的最大独立集

**状态**：`dp[u][0/1]`
 **转移**见上一节；注意**树上背包**时子树合并顺序。

------

## 16. 课堂示例 D：数位 DP（无相邻重复数字计数）

**状态**：`f[pos][last_digit][tight][lead]`
 **转移**：枚举当前位 `d`，若 `tight` 则 `d ≤ limit[pos]`；若 `lead` 则可放 0 且不受相邻约束。

------

## 17. 课堂示例 E：TSP 状压 DP

**状态**：`dp[mask][u]`
 **转移**：从 `u` 走到 `v`：`dp[mask|1<<v][v] = min(...)`
 **复杂度**：`O(n^2 · 2^n)`，`n≤20` 以内可做。

------

## 18. 竞赛常见题型映射

- USACO/NOIP：背包族、区间石子、树独立集/直径、DAG 路径计数、数位 DP。
- LeetCode 高频：打家劫舍、零钱兑换、不同路径、编辑距离、LCS/LIS 变体、正则匹配。

------

## 19. 训练题单（由易到难）

1. **入门**：爬楼梯、斐波那契、不同路径、0-1 背包、LCS
2. **进阶**：石子合并、编辑距离、树的最大独立集、完全背包、多重背包
3. **提高**：区间 DP 优化（Knuth/分治）、TSP、数位 DP（不含某数位）、DAG 最长路
4. **挑战**：CHT 斜率优化类、树上背包、分组背包 + 单调队列、期望 DP

> 作业建议：每类至少 2 题；写出**状态定义与转移式**，并在代码顶部注释。

------

## 20. 一页速查表（可打印）

- **套路**：定义状态 → 写转移 → 定边界 → 定顺序 → 找答案。
- **常用初始化**：`max` 型置 `-inf`，`min` 型置 `+inf`；`dp[0]=0/1` 视语义。
- **顺序要诀**：
  - 线性依赖：小到大/大到小（背包）
  - 区间：按长度
  - 树上：后序 DFS
  - DAG：拓扑序
- **优化指针**：滚动数组 / 单调队列 / CHT / 分治 / Knuth / bitset
- **调试清单**：边界、方向、覆盖、污染、越界、取模、答案位置。

------

## 21. 附：黑板化推导范式（讲解用）

1. 画依赖图：节点=状态，边=转移。
2. 写原问题的“分解等式”。
3. 根据约束抉择**维度与下标**。
4. 写伪代码并手算一个小样例验证。
5. 再考虑是否可优化（单调性、凸性、分治）。

------

## 22. 参考代码片段（C++/Python）

> 课堂仅展示关键片段；完整代码建议课后自练。

**0-1 背包（C++，滚动一维）**

```cpp
for (int i=1;i<=n;i++){
  for (int w=W; w>=wi[i]; --w)
    dp[w]=max(dp[w], dp[w-wi[i]]+vi[i]);
}
```

**区间 DP 顺序**

```python
for length in range(2, n+1):
    for l in range(1, n-length+2):
        r = l + length - 1
        for k in range(l, r):
            dp[l][r] = min(dp[l][r], dp[l][k]+dp[k+1][r]+cost(l,r))
```

------

