## 🧩 4. 经典模型 II：背包 DP（必会）

### 4.1 0-1 背包

- 状态：`dp[w] = 容量为 w 时的最大价值`（滚动一维）
- 转移：**倒序**枚举 `w`：`dp[w] = max(dp[w], dp[w-weight]+value)`

### 4.2 完全背包 / 多重背包

- 完全：`w` **正序**；多重：二进制拆分到 0-1 背包。

### 4.3 体积/费用多维背包

- 多维度约束：`dp[w1][w2]...`，维数↑ → 复杂度爆炸，考虑剪枝/启发式/混合搜索。

------

## 🧩 5. 经典模型 III：区间 DP

- 场景：括号匹配、石子合并、凸多边形三角剖分。
- 通式：`dp[l][r] = min_{k∈(l,r)} dp[l][k] + dp[k+1][r] + cost(l,r,k)`
- 计算顺序：按区间长度 `len` 从小到大。

**例：石子合并**

- `sum[i]` 为前缀和，`cost = sum[r]-sum[l-1]`
- `O(n^3)`；若满足**四边形不等式**，可用 **Knuth/Divide & Conquer** 优化到 `O(n^2)`。

------

## 🧩 6. 经典模型 IV：树上 DP

- **树的直径**、**最大独立集**、**重心**、**树形背包**。
- 常见套路：树形 `dfs(u,fa)`，子树合并时注意转移顺序与临时数组。

**例：树的最大独立集（无相邻点同时选）**

- `dp[u][0/1]`：u 不选/选的最大点权
- 转移：`dp[u][1] = val[u] + Σ dp[v][0]`，`dp[u][0] = Σ max(dp[v][0], dp[v][1])`。

------

## 🧩 7. 经典模型 V：图上 DP（DAG）

- 在 DAG 上按拓扑序进行转移（最长路/计数路径）。
- 也可作为“序列 DP 的广义版”。

------

## 🧩 8. 经典模型 VI：数位 DP（Digit DP）

- 问题：统计区间 [0..N] 中满足某性质的整数个数。
- 状态：`f[pos][tight][lead][...属性...]`
- 细节：处理**前导零**与**上界约束 tight**；通常 `O(位数 * 状态数 * 备选数字)`。

------

## 🧩 9. 经典模型 VII：状压 DP（Bitmask）

- 适用：`n ≤ 20~25` 的子集枚举类，如**TSP**、**分配问题**、**最大团近似**。
- 例（TSP 最短路）：`dp[mask][u] = 访问过 mask，当前在 u 的最短路`，转移枚举下一个点。

------

## 🧩 10. 常见优化

### 10.1 空间优化（滚动数组）

- 条件：`f[i]` 仅依赖 `f[i-1]`；注意遍历方向防止“新值污染旧值”。

### 10.2 单调队列优化（Convex/Monotone Queue）

- 例：`dp[i] = min(dp[i-1]) + cost(i)` + **窗口限制**；或**斜率优化**对应 `w[i]` 单调。

### 10.3 斜率优化（Convex Hull Trick, CHT）

- 形式：`dp[i] = min_j (m_j * x_i + b_j)`，维护下凸包；在线/离线两种实现。

### 10.4 分治优化

- 形式：`dp[l..r]` 的决策点 `opt[l..r]` 单调，递归分治求最优决策，复杂度从 `O(n^2)` 降至 `O(n log n)`。

### 10.5 四边形不等式（Knuth 优化）

- 适用形如区间合并的 DP，需满足 `opt[l][r-1] ≤ opt[l][r] ≤ opt[l+1][r]`。

### 10.6 Bitset 加速

- 如 0-1 背包可用位运算将 `O(nW)` 降为 `O(W/word_size * n)`，或求可达和集合。

------

## 🧩 11. 复杂度评估 & 迁移思维

- **状态数 × 转移代价 = 总复杂度**；先减状态，再减转移。
- 当 `n, m, W` 较大：考虑**近似/期望 DP**、**分层图**、**混合贪心**、**启发式搜索**。



------

## 13. 课堂示例 A：0-1 背包（滚动一维）

**题意**：容量 `W`，`n` 件物品 `(w_i, v_i)`，求最大价值。
 **状态**：`dp[w]`
 **初始化**：`dp[0]=0，其余 -inf`（或 0 取“不能超过容量”的意义）
 **转移**：`for i in items: for w=W..w_i: dp[w] = max(dp[w], dp[w-w_i]+v_i)`
 **注意**：倒序遍历 `w`，防重复使用。

------

## 14. 课堂示例 B：区间石子合并（Knuth 条件）

**题意**：n 堆石子环/链合并成一堆，费用为区间和。
 **状态**：`dp[l][r]`
 **转移**：`dp[l][r] = min_k dp[l][k]+dp[k+1][r]+sum(l,r)`
 **优化**：若满足四边形不等式，`O(n^2)` 实现；否则 `O(n^3)`。

------

## 15. 课堂示例 C：树的最大独立集

**状态**：`dp[u][0/1]`
 **转移**见上一节；注意**树上背包**时子树合并顺序。

------

## 16. 课堂示例 D：数位 DP（无相邻重复数字计数）

**状态**：`f[pos][last_digit][tight][lead]`
 **转移**：枚举当前位 `d`，若 `tight` 则 `d ≤ limit[pos]`；若 `lead` 则可放 0 且不受相邻约束。

------

## 17. 课堂示例 E：TSP 状压 DP

**状态**：`dp[mask][u]`
 **转移**：从 `u` 走到 `v`：`dp[mask|1<<v][v] = min(...)`
 **复杂度**：`O(n^2 · 2^n)`，`n≤20` 以内可做。

------

## 18. 竞赛常见题型映射

- USACO/NOIP：背包族、区间石子、树独立集/直径、DAG 路径计数、数位 DP。
- LeetCode 高频：打家劫舍、零钱兑换、不同路径、编辑距离、LCS/LIS 变体、正则匹配。

------

## 19. 训练题单（由易到难）

1. **入门**：爬楼梯、斐波那契、不同路径、0-1 背包、LCS
2. **进阶**：石子合并、编辑距离、树的最大独立集、完全背包、多重背包
3. **提高**：区间 DP 优化（Knuth/分治）、TSP、数位 DP（不含某数位）、DAG 最长路
4. **挑战**：CHT 斜率优化类、树上背包、分组背包 + 单调队列、期望 DP

> 作业建议：每类至少 2 题；写出**状态定义与转移式**，并在代码顶部注释。

------

## 20. 一页速查表（可打印）

- **套路**：定义状态 → 写转移 → 定边界 → 定顺序 → 找答案。
- **常用初始化**：`max` 型置 `-inf`，`min` 型置 `+inf`；`dp[0]=0/1` 视语义。
- **顺序要诀**：
  - 线性依赖：小到大/大到小（背包）
  - 区间：按长度
  - 树上：后序 DFS
  - DAG：拓扑序
- **优化指针**：滚动数组 / 单调队列 / CHT / 分治 / Knuth / bitset
- **调试清单**：边界、方向、覆盖、污染、越界、取模、答案位置。

------

## 21. 附：黑板化推导范式（讲解用）

1. 画依赖图：节点=状态，边=转移。
2. 写原问题的“分解等式”。
3. 根据约束抉择**维度与下标**。
4. 写伪代码并手算一个小样例验证。
5. 再考虑是否可优化（单调性、凸性、分治）。

------

## 22. 参考代码片段（C++/Python）

> 课堂仅展示关键片段；完整代码建议课后自练。

**0-1 背包（C++，滚动一维）**

```cpp
for (int i=1;i<=n;i++){
  for (int w=W; w>=wi[i]; --w)
    dp[w]=max(dp[w], dp[w-wi[i]]+vi[i]);
}
```

**区间 DP 顺序**

```python
for length in range(2, n+1):
    for l in range(1, n-length+2):
        r = l + length - 1
        for k in range(l, r):
            dp[l][r] = min(dp[l][r], dp[l][k]+dp[k+1][r]+cost(l,r))
```

------

