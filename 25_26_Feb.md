## USACO 2026 January Contest, Silver

**Problem 2. Declining Invitations** (动态维护题)

🧩 题意：

> 有 N 个选手，比赛名次是 1 到 N（1 是最好）。
>
> 有 C 个邀请条件（criteria），编号 1..C。
>
> 每个选手 `rank = i` 会满足若干个条件：题目给你一个列表，告诉你他满足哪些条件。
>
> 每个条件 j 有一个整数 `f[j]`：表示在第 j 步最多邀请多少人。
>
> 当你考虑第 i 次情况时，表示 p1..pi 这些名次的选手都拒绝参加（decline）。

### 邀请流程

给定当前哪些人拒绝参加（declined），邀请流程按条件顺序从 1 到 C 做：

### 第 1 条件

- 在所有没有拒绝的人里，挑出满足条件 1的人。
- 按名次从小到大（越靠前越好）选前 `f1` 个，邀请他们。
- 如果不足 `f1` 个，就把能选到的全邀请。

### 第 2 条件

- 现在看还没被邀请、且没有拒绝的人。
- 从里面挑出满足条件 2的人。
- 再按名次从小到大选前 `f2` 个邀请（不足就全邀请）。

##### …一直到条件 C

- 每一步都只能从“还没被邀请 + 没拒绝”的人里选。

### 拒绝参加

如果某些选手拒绝参加：

- 他们就当作从名单里消失了。
- 邀请时不考虑他们；如果他们原本会被邀请，也会被跳过，邀请名额会顺延给后面的人（如果有合格人）。

### 输出

对每个 `i = 0 .. N-1`：

- 当 **前 i 个拒绝的人**（名次为 `p1..pi`）不参加时，
- 重新跑一遍上面的邀请流程，
- 得到最终被邀请的那批人（是一组名次/选手）。
- 输出：**这些被邀请选手的名次之和**。

## 例 2:

流程是按条件 1→2→3→4，且每个条件只邀请 **1** 人：

- 条件1：在“未被邀请且未拒绝”的人里，挑满足条件1的最好名次 1 个
- 条件2：再从剩下的人里挑满足条件2的最好名次 1 个
- 条件3：同理
- 条件4：同理

### i=0：没人拒绝（输出 10）

按条件走一遍：

- 条件1：满足1的有 {1,2}，选最小名次 ⇒ 邀请 **1**
- 条件2：剩下 {2,3,4,5}，满足2的有 {2,3} ⇒ 邀请 **2**
- 条件3：剩下 {3,4,5}，满足3的有 {3,4} ⇒ 邀请 **3**
- 条件4：剩下 {4,5}，满足4的有 {4,5} ⇒ 邀请 **4**

邀请集合：{1,2,3,4}
 和 = 1+2+3+4 = **10** 

### i=1：1 拒绝（输出 14）

- 条件1：满足1的 {1,2} 但 1 拒绝 ⇒ 邀请 **2**
- 条件2：剩 {3,4,5}，满足2的 {3} ⇒ 邀请 **3**
- 条件3：剩 {4,5}，满足3的 {4} ⇒ 邀请 **4**
- 条件4：剩 {5}，满足4的 {5} ⇒ 邀请 **5**

邀请集合：{2,3,4,5}
 和 = 2+3+4+5 = **14** 

### i=2：1,2 拒绝（输出 12）

- 条件1：满足1的 {1,2} 都拒绝 ⇒ 邀请 **没人**
- 条件2：剩 {3,4,5}，满足2的 {3} ⇒ 邀请 **3**
- 条件3：剩 {4,5}，满足3的 {4} ⇒ 邀请 **4**
- 条件4：剩 {5}，满足4的 {5} ⇒ 邀请 **5**

邀请集合：{3,4,5}
 和 = 3+4+5 = **12** 

### i=3：1,2,3 拒绝（输出 9）

- 条件1：没人
- 条件2：没人
- 条件3：剩 {4,5}，满足3的 {4} ⇒ 邀请 **4**
- 条件4：剩 {5}，满足4的 {5} ⇒ 邀请 **5**

和 = 4+5 = **9** 

### i=4：1,2,3,4 拒绝（输出 5）

- 只剩 {5}
- 条件4 会邀请 5（前面条件都邀请不到人）

和 = **5** 

所以输出依次是：
 `10, 14, 12, 9, 5`，与 sample 完全一致。

🎯 思路：

每次删人直接重跑复杂度 O(CN) 过高。

- 每个条件按 rank 从小到大“捞人”,但不能捞走已经被更早条件邀请过的人。
- 有人 decline 就相当于从名单里删掉
- 删掉一个人，只会引发“某个条件少了人 → 去自己池子里补人 → 可能抢走后面条件的人 → 后面条件再补……”的**连锁反应**

3个核心点：

**1）把原流程等价成分阶段占人：**

`stage[u]=j`：他最终是在第 j 个条件阶段被邀请的，`stage[u]=INF`：没被邀请。

 对 j=1..C，阶段 j 想把自己的人数补到 `f[j]`，每次从“满足条件 j 且 没被更早阶段占走的人里”挑**rank 最小**的。

这一步把题目从“复杂流程”变成了“**阶段配额 + 贪心选最小 rank**”的模型。

**2）拒绝导致的变化是“缺口 → 补位 → 可能抢人 → 连锁”。**

当某个选手拒绝：

- 如果他没被邀请：答案不变
- 如果他在阶段 j：阶段 j 立刻出现一个缺口（少 1 人）

为了修复缺口，阶段 j 会去自己的候选池里找下一个最小 rank 的可用选手补上。
 但这个补上的人可能原本属于某个更晚阶段 k（`k>j`），于是：

- 阶段 j 抢走他
- 阶段 k 出现缺口
- 阶段 k 再补位……

所以拒绝只会引发一条（或多条）**向后传播的连锁补位**。

**3）用“排序候选 + 单调指针”把总时间压到线性**

对每个条件 j：

- 把所有满足 j 的选手按 rank 排序成 `cand[j]`
- 用指针 `ptr[j]` 从前往后扫，找下一个可用的人

可用条件是：

- 没拒绝
- `stage[u] > j`

为了按顺序处理缺口，用一个小根堆维护“当前缺人的阶段”，不断 `fill(j)` 直到所有缺口补完。

### 💡 代码逻辑：

- 先在无人拒绝情况下跑一遍 `fill(1..C)` 得到初始 `sum`
- 对 i=0..N-1：
  - 输出当前 `sum`
  - 让 `p[i+1]` 拒绝
  - 若它在某阶段：该阶段入堆
  - while 堆非空：取最小阶段 j，执行 `fill(j)`（可能继续制造后面阶段缺口入堆）

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, C;
    cin >> N >> C;

    // f[j]：第 j 个条件最多邀请的人数（名额上限）
    vector<int> f(C + 1);
    for (int j = 1; j <= C; j++) cin >> f[j];

    // p[1..N]：拒绝顺序；第 i 次情景表示 p[1..i] 全部拒绝
    vector<int> p(N + 1);
    for (int i = 1; i <= N; i++) cin >> p[i];

    // cand[j]：满足条件 j 的选手 rank 列表（之后排序，按 rank 从小到大）
    vector<vector<int>> cand(C + 1);

    // 输入每个选手 i 满足哪些条件，把 i 加进对应条件的 cand 列表
    for (int i = 1; i <= N; i++) {
        int ni;
        cin >> ni;
        while (ni--) {
            int c;
            cin >> c;
            cand[c].push_back(i);
        }
    }

    // 每个条件的候选人按 rank 升序（题意“top”就是 rank 最小）
    for (int j = 1; j <= C; j++) sort(cand[j].begin(), cand[j].end());

    const int INF = C + 1;

    // stage[u]：选手 u 最终是被哪个条件邀请的
    // stage[u] = j 表示被条件 j 邀请；stage[u] = INF 表示没被邀请
    vector<int> stage(N + 1, INF);

    // declined[u]：选手 u 是否拒绝参加（拒绝则在邀请流程中“被忽略”）
    vector<char> declined(N + 1, 0);

    // ptr[j]：条件 j 扫描 cand[j] 的指针（单调递增，摊还线性关键）
    vector<int> ptr(C + 1, 0);

    // cnt[j]：当前已经分配到条件 j 的人数（stage==j 的人数）
    vector<int> cnt(C + 1, 0);

    // sum：当前所有被邀请者（stage!=INF）的 rank 之和 = 题目要输出的值
    long long sum = 0;

    // 小根堆：保存“缺人需要补位”的条件编号（按条件编号小的优先补，符合题意顺序）
    priority_queue<int, vector<int>, greater<int>> pq;

    // inq[j]：条件 j 是否已经在 pq 里（避免重复入堆）
    vector<char> inq(C + 1, 0);

    // 如果条件 j 人数不足 f[j]，把 j 放进 pq 等待补位
    auto push_need = [&](int j) {
        if (j >= 1 && j <= C && cnt[j] < f[j] && !inq[j]) {
            inq[j] = 1;
            pq.push(j);
        }
    };

    // fill(j)：让条件 j “尽力补满”到 f[j]
    // 补位时从 cand[j] 里找 rank 最小的、且没拒绝、且没被更早条件占走的人
    auto fill = [&](int j) {
        while (cnt[j] < f[j]) {
            auto &v = cand[j];

            // 从指针 ptr[j] 往后找可用人（ptr 单调递增，保证总扫描次数是线性的）
            while (ptr[j] < (int)v.size()) {
                int u = v[ptr[j]++];

                // 拒绝的人不能被邀请
                if (declined[u]) continue;

                // stage[u] <= j 表示 u 已经被更早条件(<=j)占走或就在 j，
                // 那么对 j 来说 u 不可用（题意：后面条件不能邀请已邀请的人）
                if (stage[u] <= j) continue;

                // 找到了可用的 u，现在把 u 分配给条件 j
                int old = stage[u];

                if (old == INF) {
                    // u 原本没被邀请，现在被邀请了
                    sum += u;
                } else {
                    // u 原本属于更晚的条件 old(>j)，现在被 j 抢走
                    // 那 old 就少了一个人，需要之后补位（连锁反应）
                    cnt[old]--;
                    push_need(old);
                }
                stage[u] = j;
                cnt[j]++;
                break;
            }

            // cand[j] 已经扫完仍补不满，说明条件 j 的合格剩余人不够了，停
            if (cnt[j] < f[j] && ptr[j] >= (int)cand[j].size()) break;
        }
    };

    // 先在“无人拒绝”的情况下，按条件 1..C 完整跑一遍，建立初始邀请分配
    for (int j = 1; j <= C; j++) {
        if (f[j] > 0) fill(j);
    }

    // 题目要求输出 N 行，对应 i=0..N-1 的情景：
    // 第 i 行输出：拒绝 p[1..i] 后的邀请名单 rank 之和
    for (int i = 0; i <= N - 1; i++) {
        cout << sum << "\n";

        // 接下来进入下一情景：再多一个人拒绝（rank = p[i+1]）
        int r = p[i + 1];
        declined[r] = 1;

        // 如果 r 本来就没被邀请，拒绝不会影响邀请名单
        int s = stage[r];
        if (s != INF) {
            // r 本来被条件 s 邀请，现在拒绝 => 从邀请集合移除
            stage[r] = INF;
            cnt[s]--;
            sum -= r;

            // 条件 s 出现缺口，需要补位
            push_need(s);
        }

        // 不断补位直到所有缺口修复完
        while (!pq.empty()) {
            int j = pq.top();
            pq.pop();
            inq[j] = 0;
            if (cnt[j] < f[j]) fill(j);
        }
    }

    return 0;
}
```
