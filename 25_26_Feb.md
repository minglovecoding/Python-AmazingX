## USACO 2026 January Contest, Silver

### **Problem 2. Declining Invitations** (动态维护题)

🧩 题意：

> 有 N 个选手，比赛名次是 1 到 N（1 是最好）。
>
> 有 C 个邀请条件（criteria），编号 1..C。
>
> 每个选手 `rank = i` 会满足若干个条件：题目给你一个列表，告诉你他满足哪些条件。
>
> 每个条件 j 有一个整数 `f[j]`：表示在第 j 步最多邀请多少人。
>
> 当你考虑第 i 次情况时，表示 p1..pi 这些名次的选手都拒绝参加（decline）。

### 邀请流程

给定当前哪些人拒绝参加（declined），邀请流程按条件顺序从 1 到 C 做：

### 第 1 条件

- 在所有没有拒绝的人里，挑出满足条件 1的人。
- 按名次从小到大（越靠前越好）选前 `f1` 个，邀请他们。
- 如果不足 `f1` 个，就把能选到的全邀请。

### 第 2 条件

- 现在看还没被邀请、且没有拒绝的人。
- 从里面挑出满足条件 2的人。
- 再按名次从小到大选前 `f2` 个邀请（不足就全邀请）。

##### …一直到条件 C

- 每一步都只能从“还没被邀请 + 没拒绝”的人里选。

### 拒绝参加

如果某些选手拒绝参加：

- 他们就当作从名单里消失了。
- 邀请时不考虑他们；如果他们原本会被邀请，也会被跳过，邀请名额会顺延给后面的人（如果有合格人）。

### 输出

对每个 `i = 0 .. N-1`：

- 当 **前 i 个拒绝的人**（名次为 `p1..pi`）不参加时，
- 重新跑一遍上面的邀请流程，
- 得到最终被邀请的那批人（是一组名次/选手）。
- 输出：**这些被邀请选手的名次之和**。

## 例 2:

流程是按条件 1→2→3→4，且每个条件只邀请 **1** 人：

- 条件1：在“未被邀请且未拒绝”的人里，挑满足条件1的最好名次 1 个
- 条件2：再从剩下的人里挑满足条件2的最好名次 1 个
- 条件3：同理
- 条件4：同理

### i=0：没人拒绝（输出 10）

按条件走一遍：

- 条件1：满足1的有 {1,2}，选最小名次 ⇒ 邀请 **1**
- 条件2：剩下 {2,3,4,5}，满足2的有 {2,3} ⇒ 邀请 **2**
- 条件3：剩下 {3,4,5}，满足3的有 {3,4} ⇒ 邀请 **3**
- 条件4：剩下 {4,5}，满足4的有 {4,5} ⇒ 邀请 **4**

邀请集合：{1,2,3,4}
 和 = 1+2+3+4 = **10** 

### i=1：1 拒绝（输出 14）

- 条件1：满足1的 {1,2} 但 1 拒绝 ⇒ 邀请 **2**
- 条件2：剩 {3,4,5}，满足2的 {3} ⇒ 邀请 **3**
- 条件3：剩 {4,5}，满足3的 {4} ⇒ 邀请 **4**
- 条件4：剩 {5}，满足4的 {5} ⇒ 邀请 **5**

邀请集合：{2,3,4,5}
 和 = 2+3+4+5 = **14** 

### i=2：1,2 拒绝（输出 12）

- 条件1：满足1的 {1,2} 都拒绝 ⇒ 邀请 **没人**
- 条件2：剩 {3,4,5}，满足2的 {3} ⇒ 邀请 **3**
- 条件3：剩 {4,5}，满足3的 {4} ⇒ 邀请 **4**
- 条件4：剩 {5}，满足4的 {5} ⇒ 邀请 **5**

邀请集合：{3,4,5}
 和 = 3+4+5 = **12** 

### i=3：1,2,3 拒绝（输出 9）

- 条件1：没人
- 条件2：没人
- 条件3：剩 {4,5}，满足3的 {4} ⇒ 邀请 **4**
- 条件4：剩 {5}，满足4的 {5} ⇒ 邀请 **5**

和 = 4+5 = **9** 

### i=4：1,2,3,4 拒绝（输出 5）

- 只剩 {5}
- 条件4 会邀请 5（前面条件都邀请不到人）

和 = **5** 

所以输出依次是：
 `10, 14, 12, 9, 5`，与 sample 完全一致。

🎯 思路：

每次删人直接重跑复杂度 O(CN) 过高。

- 每个条件按 rank 从小到大“捞人”,但不能捞走已经被更早条件邀请过的人。
- 有人 decline 就相当于从名单里删掉
- 删掉一个人，只会引发“某个条件少了人 → 去自己池子里补人 → 可能抢走后面条件的人 → 后面条件再补……”的**连锁反应**

3个核心点：

**1）把原流程等价成分阶段占人：**

`stage[u]=j`：他最终是在第 j 个条件阶段被邀请的，

`stage[u]=INF`：没被邀请。

 对 j=1..C，阶段 j 想把自己的人数补到 `f[j]`，每次从“满足条件 j 且 没被更早阶段占走的人里”挑**rank 最小**的。

这一步把题目从“复杂流程”变成了“**阶段配额 + 贪心选最小 rank**”的模型。

**2）拒绝导致的变化是“缺口 → 补位 → 可能抢人 → 连锁”。**

当某个选手拒绝：

- 如果他没被邀请：答案不变
- 如果他在阶段 j：阶段 j 立刻出现一个缺口（少 1 人）

为了修复缺口，阶段 j 会去自己的候选池里找下一个最小 rank 的可用选手补上。
 但这个补上的人可能原本属于某个更晚阶段 k（`k>j`），于是：

- 阶段 j 抢走他
- 阶段 k 出现缺口
- 阶段 k 再补位……

所以拒绝只会引发一条（或多条）**向后传播的连锁补位**。

**3）用“排序候选 + 单调指针”把总时间压到线性**

对每个条件 j：

- 把所有满足 j 的选手按 rank 排序成 `cand[j]`
- 用指针 `ptr[j]` 从前往后扫，找下一个可用的人

可用条件是：

- 没拒绝
- `stage[u] > j`

为了按顺序处理缺口，用一个小根堆维护“当前缺人的阶段”，不断 `fill(j)` 直到所有缺口补完。

### 💡 代码逻辑：

- 先在无人拒绝情况下跑一遍 `fill(1..C)` 得到初始 `sum`
- 对 i=0..N-1：
  - 输出当前 `sum`
  - 让 `p[i+1]` 拒绝
  - 若它在某阶段：该阶段入堆
  - while 堆非空：取最小阶段 j，执行 `fill(j)`（可能继续制造后面阶段缺口入堆）

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, C;
    cin >> N >> C;

    // f[j]：第 j 个条件最多邀请的人数（名额上限）
    vector<int> f(C + 1);
    for (int j = 1; j <= C; j++) cin >> f[j];

    // p[1..N]：拒绝顺序；第 i 次情景表示 p[1..i] 全部拒绝
    vector<int> p(N + 1);
    for (int i = 1; i <= N; i++) cin >> p[i];

    // cand[j]：满足条件 j 的选手 rank 列表（之后排序，按 rank 从小到大）
    vector<vector<int>> cand(C + 1);

    // 输入每个选手 i 满足哪些条件，把 i 加进对应条件的 cand 列表
    for (int i = 1; i <= N; i++) {
        int ni;
        cin >> ni;
        while (ni--) {
            int c;
            cin >> c;
            cand[c].push_back(i);
        }
    }

    // 每个条件的候选人按 rank 升序（题意“top”就是 rank 最小）
    for (int j = 1; j <= C; j++) sort(cand[j].begin(), cand[j].end());

    const int INF = C + 1;

    // stage[u]：选手 u 最终是被哪个条件邀请的
    // stage[u] = j 表示被条件 j 邀请；stage[u] = INF 表示没被邀请
    vector<int> stage(N + 1, INF);

    // declined[u]：选手 u 是否拒绝参加（拒绝则在邀请流程中“被忽略”）
    vector<char> declined(N + 1, 0);

    // ptr[j]：条件 j 扫描 cand[j] 的指针（单调递增，摊还线性关键）
    vector<int> ptr(C + 1, 0);

    // cnt[j]：当前已经分配到条件 j 的人数（stage==j 的人数）
    vector<int> cnt(C + 1, 0);

    // sum：当前所有被邀请者（stage!=INF）的 rank 之和 = 题目要输出的值
    long long sum = 0;

    // 小根堆：保存“缺人需要补位”的条件编号（按条件编号小的优先补，符合题意顺序）
    priority_queue<int, vector<int>, greater<int>> pq;

    // inq[j]：条件 j 是否已经在 pq 里（避免重复入堆）
    vector<char> inq(C + 1, 0);

    // 如果条件 j 人数不足 f[j]，把 j 放进 pq 等待补位
    auto push_need = [&](int j) {
        if (j >= 1 && j <= C && cnt[j] < f[j] && !inq[j]) {
            inq[j] = 1;
            pq.push(j);
        }
    };

    // fill(j)：让条件 j “尽力补满”到 f[j]
    // 补位时从 cand[j] 里找 rank 最小的、且没拒绝、且没被更早条件占走的人
    auto fill = [&](int j) {
        while (cnt[j] < f[j]) {
            auto &v = cand[j];

            // 从指针 ptr[j] 往后找可用人（ptr 单调递增，保证总扫描次数是线性的）
            while (ptr[j] < (int)v.size()) {
                int u = v[ptr[j]++];

                // 拒绝的人不能被邀请
                if (declined[u]) continue;

                // stage[u] <= j 表示 u 已经被更早条件(<=j)占走或就在 j，
                // 那么对 j 来说 u 不可用（题意：后面条件不能邀请已邀请的人）
                if (stage[u] <= j) continue;

                // 找到了可用的 u，现在把 u 分配给条件 j
                int old = stage[u];

                if (old == INF) {
                    // u 原本没被邀请，现在被邀请了
                    sum += u;
                } else {
                    // u 原本属于更晚的条件 old(>j)，现在被 j 抢走
                    // 那 old 就少了一个人，需要之后补位（连锁反应）
                    cnt[old]--;
                    push_need(old);
                }
                stage[u] = j;
                cnt[j]++;
                break;
            }

            // cand[j] 已经扫完仍补不满，说明条件 j 的合格剩余人不够了，停
            if (cnt[j] < f[j] && ptr[j] >= (int)cand[j].size()) break;
        }
    };

    // 先在“无人拒绝”的情况下，按条件 1..C 完整跑一遍，建立初始邀请分配
    for (int j = 1; j <= C; j++) {
        if (f[j] > 0) fill(j);
    }

    // 题目要求输出 N 行，对应 i=0..N-1 的情景：
    // 第 i 行输出：拒绝 p[1..i] 后的邀请名单 rank 之和
    for (int i = 0; i <= N - 1; i++) {
        cout << sum << "\n";

        // 接下来进入下一情景：再多一个人拒绝（rank = p[i+1]）
        int r = p[i + 1];
        declined[r] = 1;

        // 如果 r 本来就没被邀请，拒绝不会影响邀请名单
        int s = stage[r];
        if (s != INF) {
            // r 本来被条件 s 邀请，现在拒绝 => 从邀请集合移除
            stage[r] = INF;
            cnt[s]--;
            sum -= r;

            // 条件 s 出现缺口，需要补位
            push_need(s);
        }

        // 不断补位直到所有缺口修复完
        while (!pq.empty()) {
            int j = pq.top();
            pq.pop();
            inq[j] = 0;
            if (cnt[j] < f[j]) fill(j);
        }
    }

    return 0;
}
```

***

🧩 题意：

> 有 N 头牛原本围成一个圆圈坐着，但现在被拉成一条直线编号 1..N。每头牛只会“描述它在原圆圈中左右相邻两头牛分别属于谁（J 或 N）”。John 的牛永远说真话，Nhoj 的牛永远说假话。问：是否存在一种把牛重新排回圆圈的顺序 + 给每头牛分配属于 John 或 Nhoj 的方案，使得所有 John 牛的陈述都为真、所有 Nhoj 牛的陈述都为假？

1. 一个整数 **N**：牛的数量（要围成一个圆）
2. 字符串 **sl**（长度 N）：
    第 i 个字符是 `J` / `N`，表示**牛 i 声称**：它在圆圈里**左边那头牛**属于 John (`J`) 还是 Nhoj (`N`)
3. 字符串 **sr**（长度 N）：
    第 i 个字符表示**牛 i 声称**：它在圆圈里**右边那头牛**属于 John 还是 Nhoj

##### 要判断/输出的东西

- 只要输出 `YES/NO`：是否存在满足条件的方案
- 如果题目给的参数 `C=1` 且答案是 `YES`，还要输出一个具体方案：
  1. 一个排列 `p1..pN`：表示圆圈顺序（`p_i` 的右边是 `p_{i+1}`，`p_N` 的右边是 `p_1`）
  2. 一个字符串 `b1..bN`：表示圆圈顺序中每头牛属于谁（`J` 表示 John，`N` 表示 Nhoj）

**直线里的编号顺序 1..N 并不等于 它们原来围成圆圈的顺序。

🎯 思路：

> 把“真话/假话 + 左右指认”的逻辑约束，转成 二元 XOR 差分，再把“环上相邻一致”转成 2 点有向图的欧拉回路 + 总 XOR 偶性，最后用欧拉回路顺序直接构造排列与阵营。

 John -> 0, Nhoj -> 1,找XOR关系 `b[i] XOR b[right(i)] = r[i]`
 `b[left(i)] XOR b[i] = l[i]`
 其中 `b[x]=0/1` 表示牛 x 真实属于 John/Nhoj。

- l[i] = (sl[i] == 'N')
- r[i] = (sr[i] == 'N')

$$
b[\text{right}] = b[i] \oplus r[i]
$$

同理左边：
$$
b[\text{left}] = b[i] \oplus l[i]
$$
于是得到非常漂亮的“差分”形式：
$$
b[i] \oplus b[\text{right}] = r[i], \quad b[\text{left}] \oplus b[i] = l[i]
$$
这里的 `l[i], r[i]` 实际可理解与邻居是否同阵营（0 同，1 不同）
$$
b[pk] \oplus b[p(k+1)] = r[pk]
$$

$$
b[pk] \oplus b[p(k+1)] = l[p(k+1)]
$$

因此必须满足：
$$
r[pk] = l[p(k+1)]
$$
这就像在拼接“2-bit 的瓷砖”(l,r)：上一块的右端要等于下一块的左端。

而“把所有牛排成一个圈，并且满足相邻拼接条件”，等价于：

> 在这个 2 点有向多重图里，找到一条 **欧拉回路**（每条边用且只用一次，并且首尾闭合）。

### **必须满足两个条件：**

条件 A：每个点入度=出度（欧拉回路必要条件）

条件 B：`r` 中 1 的个数必须为偶数
$$
b_{k+1} = b_k \oplus r[p_k]
$$

$$
r[p_1] \oplus r[p_2] \oplus \cdots \oplus r[p_N] = 0
$$

这等价于 1 的个数为**偶数**。

### Hierholzer

有向图两点 0/1，边如下：

- A: 0→1
- B: 1→0
- C: 0→0
- D: 1→1

入度=出度都成立（每点入2出2），所以有**欧拉回路**。

从 0 开始：

- 走 C: 0→0

- 走 A: 0→1

- 走 D: 1→1

- 走 B: 1→0

   现在回到 0，边用完，形成回路：C, A, D, B，这条回路中每条边恰好出现一次

### 欧拉回路

把 这题把每头牛 i 变成一条边 `l[i] -> r[i]`，其中 `l[i], r[i] ∈ {0,1}`，所以图只有两个点 0/1，但边有 N 条。

“圆圈顺序”要求相邻满足 `r[前] = l[后]`，这正是：

> 走完一条边的终点，必须是下一条边的起点

这就是“把边按可接续顺序排成一个环”——也就是欧拉回路的定义（每条边用一次且首尾闭合）。

因此：

- 能否构造圆圈顺序 ⇔ 这 2 点有向多重图是否有欧拉回路
- 代码先检查 `in==out`，再用 Hierholzer 构造并检验是否用完所有边。

```c++
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

using i64 = long long;

// 一条有向边：从当前点 u 走到 to，并且这条边对应“哪一头牛”的编号 id
struct Edge {
    int to, id;
};

int C;

void solve() {
    int n;
    if (!(cin >> n)) return;

    string sl, sr;
    cin >> sl >> sr;

    /*
      核心建模（非常重要）：
      设 b[i] ∈ {0,1} 表示牛 i 的真实阵营：
        b[i]=0 => John (说真话)
        b[i]=1 => Nhoj (说假话)

      输入给的是“牛 i 声称左/右邻居属于谁(J/N)”，但考虑真假话后可转成 XOR 关系：
        b[i] XOR b[right(i)] = r[i]
        b[left(i)] XOR b[i] = l[i]

      其中 l[i], r[i] ∈ {0,1} 被解释为：
        0: 我和邻居同阵营
        1: 我和邻居不同阵营

      而且在环上相邻拼接时必须满足：
        r[p_k] == l[p_{k+1}]
      （上一头牛的 r 必须等于下一头牛的 l）
      这就变成一个只有两个点(0/1)的有向多重图：
        每头牛 i 是一条边： l[i] -> r[i]
      找到使用每条边一次的“欧拉回路”，其边序就是环上牛的顺序。
    */

    vector<int> l(n), r(n);
    vector<int> in(2, 0), out(2, 0);

    // adj[0], adj[1] 分别存从点 0/1 出发的边（多重边）
    vector<Edge> adj[2];

    int cnt_r1 = 0; // 统计所有 r[i]=1 的数量（用于全局偶性检查）

    for (int i = 0; i < n; ++i) {
        // 把字符转成 0/1（注意：这里用 'N' 映射为 1）
        // l[i]=1 表示“牛 i 声称左邻居是 Nhoj”，等价于 XOR 差分里 l[i]=1（不同阵营）
        // r[i]=1 同理
        l[i] = (sl[i] == 'N');
        r[i] = (sr[i] == 'N');

        // 每头牛 i 对应一条边：l[i] -> r[i]，边 id = i+1（牛编号从 1 开始）
        adj[l[i]].push_back({r[i], i + 1});

        // 维护入度/出度（欧拉回路必要条件：每个点 in=out）
        out[l[i]]++;
        in[r[i]]++;

        if (r[i]) cnt_r1++;
    }

    /*
      可行性必要条件 1：欧拉回路要求每个点 in=out
      可行性必要条件 2：绕环一圈必须回到起点：
         b1 XOR b2 = r[p1]
         b2 XOR b3 = r[p2]
         ...
         bN XOR b1 = r[pN]
       XOR 全部得到 r[p1] XOR ... XOR r[pN] = 0
       => 1 的个数必须为偶数
       注意：环上的顺序只是重排，所以“所有 r[i] 的 XOR”不变，直接要求 cnt_r1 偶数即可。
    */
    if (in[0] != out[0] || in[1] != out[1] || cnt_r1 % 2 != 0) {
        cout << "NO\n";
        return;
    }

    /*
      现在在 2 点图上找欧拉回路（Hierholzer 算法）：
      - stack 记录当前走到的点序列
      - path_ids 记录走过的边 id（与 stack 同步推进）
      - 当走到一个点没有出边可走时，回退，把最后一条边加入答案
      最终得到的 ans 是“欧拉回路的边序（反向）”，最后 reverse。
    */

    // 从哪个点开始都可以；若 1 点有边则从 1 开始，否则从 0
    int start_node = adj[1].empty() ? 0 : 1;

    vector<int> ans;              // 记录欧拉回路边序（最终会变成环上牛的顺序）
    vector<int> stack = {start_node}; // 走点的栈
    vector<int> path_ids;         // 走边的栈（每次沿边深入就 push 边 id）

    while (!stack.empty()) {
        int u = stack.back();
        if (!adj[u].empty()) {
            // 还有边可走：取出一条 u->to 的边，沿着它走
            Edge e = adj[u].back();
            adj[u].pop_back();

            stack.push_back(e.to);
            path_ids.push_back(e.id);
        } else {
            // 没边可走：回退
            stack.pop_back();

            // 回退时把“刚刚完成的那条边”加入答案（Hierholzer 的标准写法）
            if (!path_ids.empty()) {
                ans.push_back(path_ids.back());
                path_ids.pop_back();
            }
        }
    }

    // 必须用掉所有 n 条边，否则说明图不是一个连通的欧拉回路结构（边分散在多个部分）
    if (ans.size() != (size_t)n) {
        cout << "NO\n";
        return;
    }

    cout << "YES\n";

    if (C == 1) {
        // Hierholzer 得到的是反序边序，翻转后就是从 p1 到 pN 的顺序
        reverse(ans.begin(), ans.end());

        // 输出环上顺序：p1..pN（这里每条边 id 就是牛编号）
        for (int i = 0; i < n; ++i) {
            cout << ans[i] << (i == n - 1 ? "" : " ");
        }
        cout << "\n";

        /*
          构造阵营字符串 b（对应环上顺序 p=ans）：
          令 current_state = b[p1]，我们可以任意取 0（John）作为起点。
          然后利用关系：
            b[p_{k+1}] = b[p_k] XOR r[p_k]
          依次推下去得到整圈的 b。
          由于我们前面保证了所有 r 的 XOR 为 0，所以走完一圈会回到起点，合法闭环。
        */
        string res = "";
        int current_state = 0; // 0->J, 1->N

        for (int i = 0; i < n; ++i) {
            res += (current_state == 0 ? 'J' : 'N');

            // 下一头牛的阵营 = 当前阵营 XOR 当前牛的 r 值
            // 注意 r 数组是按牛编号 i 存的，所以要用 ans[i]-1 来索引
            current_state ^= r[ans[i] - 1];
        }

        cout << res << "\n";
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    if (cin >> T >> C) {
        while (T--) solve();
    }
    return 0;
}

```

***

### Problem 3. Farmer John Loves Rotations

🧩 题意：

> 固定你喜欢的位置 j 不动，但你可以把整个数组循环左/右移动；每移动一次就把“此时位置 j上的数”记到纸上，问最少要移动多少次才能让纸上出现数组里所有不同的值（集合 S 里的每个值至少出现一次）。并且要对每个 j=1..N 都分别求答案。

🎯 思路：

1. 计算不同值数 `K`

2. 把环复制成 `B`

3. 双指针求每个 `l` 的最短覆盖右端 `rmin[l]`

4. 每个覆盖区间 `[l,rmin[l]]` 对任意 `pos` 的最少步数是
   $$
   (r-l) + \min(pos-l,\; r-pos)
   $$
   转成两条线性式 `(r-2l)+pos` 与 `(2r-l)-pos`

5. 扫描 `pos`，维护所有包含 `pos` 的区间，取最小线性值

6. 再补一个“只往左走”特例 `bestLeft`

7. 对每个 `j` 看 `j` 和 `j+N` 两个展开位置取最小

```C++
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
const ll INF = (1LL<<62);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;
    vector<int> A(N+1);
    for(int i=1;i<=N;i++) cin >> A[i];
   //算出不同值个数
    vector<int> seen(N+1,0);
    int K=0;
    for(int i=1;i<=N;i++){
        if(!seen[A[i]]) { seen[A[i]]=1; K++; }
    }
    //构造长度 2N 的数组 B，环上连续一段当成B数组的普通区间[l,r]
    int M = 2*N;
    vector<int> B(M+1);
    for(int i=1;i<=M;i++){
        int idx = (i-1)%N + 1;
        B[i] = A[idx];
    }
    
  //求最短的 r 使得区间 [l,r] 覆盖全部 K 个值
    vector<int> cnt(N+1,0);
    int distinct = 0;
    int r = 0;

    vector<int> rmin(N+1,0);
    vector<ll> valA(N+1,0), valB(N+1,0);

    auto addVal = [&](int x){
        if(cnt[x]==0) distinct++;
        cnt[x]++;
    };
    auto remVal = [&](int x){
        cnt[x]--;
        if(cnt[x]==0) distinct--;
    };

    for(int l=1;l<=N;l++){
        int target = l + N - 1;           
        while(distinct < K && r < target){
            ++r;
            addVal(B[r]);
        }
        
        rmin[l] = r;//以 l 开头的最短覆盖区间的右端点。
        //从“覆盖区间”到“最少步数”的公式 
        //cost([l,r],pos)=(r−l)+min(pos−l,r−pos)
        valA[l] = (ll)r - 2LL*l;//先去左端
        valB[l] = 2LL*r - (ll)l;//先去右端

        remVal(B[l]);
    }
   //扫一遍 pos，维护所有“包含 pos 的区间”的最小 valA / valB
   //这就是一个区间最小值在线查询问题：每个 l 产生一个区间 [l, rmin[l]]。
    auto sweepMin = [&](const vector<ll>& vals)->vector<ll>{
        vector<ll> res(M+1, INF);

        priority_queue<pair<ll,int>, vector<pair<ll,int>>, greater<pair<ll,int>>> active, dead;
        int del_ptr = 1; 

        for(int pos=1; pos<=M; pos++){
            if(pos <= N){
                active.push({vals[pos], pos}); 
            }
            while(del_ptr <= N && rmin[del_ptr] + 1 == pos){
                dead.push({vals[del_ptr], del_ptr});
                del_ptr++;
            }
            while(!active.empty() && !dead.empty() && active.top() == dead.top()){
                active.pop();
                dead.pop();
            }
            if(!active.empty()) res[pos] = active.top().first;
        }
        return res;
    };

    vector<ll> minA = sweepMin(valA);//所有覆盖 pos 的区间里最小的 valA[l]
    vector<ll> minB = sweepMin(valB);//所有覆盖 pos 的区间里最小的 valB[l]

    vector<ll> bestV(M+1, INF);
    for(int pos=1; pos<=M; pos++){
        ll cand = INF;
        if(minA[pos] != INF) cand = min(cand, minA[pos] + pos);
        if(minB[pos] != INF) cand = min(cand, minB[pos] - pos);
        bestV[pos] = cand;
    }
    //有时最优策略可能是：从 pos 只往左走就能遇到所有种类（完全不需要折返）。
    //码用指针 p 维护“所有满足 rmin[l] <= pos 的最大 l”，并取最接近 pos 的那个
    vector<ll> bestLeft(M+1, INF);
    int p = 0; 
    for(int pos=1; pos<=M; pos++){
        while(p < N && rmin[p+1] <= pos) p++;
        int best_l = min(p, min(N, pos));
        if(best_l >= pos - N + 1 && best_l > 0){
            bestLeft[pos] = (ll)pos - best_l;
        }
    }
    //因为原题是在环上，而我们把它展开成 B[1..2N]。
    //同一个原始下标 j 在展开后会出现两次：
    //环上“跨越 1 和 N 的那段区间”会在第二圈那份展开里变成普通区间
    for(int j=1;j<=N;j++){
        ll ans = INF;
        int p1 = j;
        int p2 = j + N;
        ans = min(ans, bestV[p1]);
        ans = min(ans, bestLeft[p1]);
        if(p2 <= M){
            ans = min(ans, bestV[p2]);
            ans = min(ans, bestLeft[p2]);
        }
        if(j>1) cout << ' ';
        cout << ans;
    }
    cout << "\n";
    return 0;
}

```

