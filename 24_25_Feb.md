## USACO 2025 February Contest, Bronze

### Problem 1. Astral Superposition

é¢˜æ„ï¼šç”»å¸ƒå¯¹ç§° + åŠ¨æ€å•ç‚¹ç¿»è½¬

æ€è·¯ï¼šæ ¸å¿ƒæ€è·¯æ˜¯æŠŠæ•´å¼  `NÃ—N`ç”»å¸ƒæŒ‰æ°´å¹³/å‚ç›´ä¸­çº¿çš„äºŒé‡å¯¹ç§°åˆ†æˆå¾ˆå¤šä¸ª4 å…ƒè½¨é“ï¼ˆorbitï¼‰æ¥ç‹¬ç«‹å¤„ç†ã€‚

### ğŸ“Œ å…³é”®è§‚å¯Ÿ

- ä»¥ä¸­çº¿ä¸ºç•Œï¼Œä»»æ„ä¸€ä¸ªæ ¼å­ `(i,j)` ï¼ŒåŠå®ƒå…³äºä¸¤æ¡ä¸­çº¿åå°„å¾—åˆ°çš„ 3 ä¸ªæ ¼å­ï¼š
  $$
  (i,j),\ (i,\,N-1-j),\ (N-1-i,\,j),\ (N-1-i,\,N-1-j)
  $$
  è¿™ 4 ä¸ªæ ¼å­æ„æˆä¸€ä¸ªè½¨é“ã€‚å› ä¸º `N` æ˜¯å¶æ•°ï¼Œæ²¡æœ‰æ ¼å­è½åœ¨ä¸­çº¿ä¸Šï¼Œæ‰€ä»¥æ¯ä¸ªè½¨é“æ°æœ‰ 4 ä¸ªæ ¼å­ï¼Œä¸åŒè½¨é“äº’ä¸ç›¸äº¤ï¼Œè¦†ç›–å…¨å›¾ã€‚

- é¢˜ç›®è¦æ±‚çš„â€œä»å³ä¸Šè±¡é™é•œåƒåˆ°å…¶å®ƒè±¡é™â€æœ¬è´¨ä¸Šè¦æ±‚ï¼šæ¯ä¸ªè½¨é“é‡Œçš„ 4 ä¸ªæ ¼å­æœ€ç»ˆå¿…é¡»ä¸€è‡´ï¼ˆè¦ä¹ˆå…¨æ˜¯â€˜#â€™ï¼Œè¦ä¹ˆå…¨æ˜¯â€˜.â€™ï¼‰ã€‚
   å› ä¸ºå³ä¸Šè±¡é™å†³å®šäº†è½¨é“çš„æœ€ç»ˆå–å€¼ï¼Œä½†å¯¹æ¯ä¸ªè½¨é“æˆ‘ä»¬éƒ½å¯ä»¥ç‹¬ç«‹é€‰æ‹©æˆâ€˜#â€™æˆ–â€˜.â€™ï¼Œäº’ä¸å½±å“ã€‚

### ğŸ“Œ æ¯ä¸ªè½¨é“çš„æœ€å°ä»£ä»·

- è®¾æŸä¸ªè½¨é“é‡Œå½“å‰æœ‰ `k`ä¸ªâ€˜#â€™ï¼ˆå…¶ä½™ `4-k` ä¸ªæ˜¯â€˜.â€™ï¼‰ï¼ŒæŠŠè¿™ä¸ªè½¨é“â€œå…¨å˜æˆåŒä¸€ä¸ªå­—ç¬¦â€çš„æœ€å°‘æ“ä½œæ˜¯ï¼š
  $$
  \min(k,\ 4-k)
  $$
  â€”â€”è¦ä¹ˆæŠŠè¿™ `k` ä¸ªâ€˜#â€™æ¸…æ‰ï¼ˆå˜â€˜.â€™ï¼‰ï¼Œè¦ä¹ˆæŠŠé‚£ `4-k` ä¸ªâ€˜.â€™æ¶‚ä¸Šï¼ˆå˜â€˜#â€™ï¼‰ï¼ŒäºŒè€…å–è¾ƒå°ã€‚

### ğŸ“Œ å…¨å±€ç­”æ¡ˆä¸æ›´æ–°

- åˆå§‹ç­”æ¡ˆå°±æ˜¯æ‰€æœ‰è½¨é“ä»£ä»·çš„æ€»å’Œï¼š
   $$
   \sum \min(k_{\text{orbit}}, 4-k_{\text{orbit}})
   $$
   
- å•ç‚¹ç¿»è½¬æ›´æ–°ï¼ˆæŠŠæŸä¸ª `(r,c)` çš„æ ¼å­â€˜#â€™â†”â€˜.â€™ï¼‰åªä¼šå½±å“å®ƒæ‰€å±çš„é‚£ä¸€ä¸ªè½¨é“çš„è®¡æ•° `k`ï¼ˆ`+1` æˆ– `-1`ï¼‰ã€‚
   åšæ³•ï¼š
  
  1. å…ˆä»æ€»ç­”æ¡ˆé‡Œå‡å»è¯¥è½¨é“åŸæ¥çš„è´¡çŒ® `min(k,4-k)`ï¼›
  2. æŒ‰ç¿»è½¬æ›´æ–°è¯¥è½¨é“çš„ `k`ï¼›
  3. å†æŠŠæ–°çš„ `min(k,4-k)` åŠ å›æ€»ç­”æ¡ˆã€‚
- è¿™æ ·æ¯æ¬¡æ›´æ–°éƒ½æ˜¯ `O(1)`ï¼Œé¢„å¤„ç†ç»Ÿè®¡æ‰€æœ‰è½¨é“çš„ `k` æ˜¯ `O(N^2)`ã€‚è½¨é“æ•°æ˜¯ `(N/2) * (N/2)`ã€‚

### ğŸ“Œ å¦‚ä½•ç»™è½¨é“ç¼–å·ï¼ˆå®ç°å°æŠ€å·§ï¼‰

æŠŠ `(i,j)` å‹åˆ°å®ƒåœ¨å·¦ä¸Šå››åˆ†ä¹‹ä¸€çš„ä»£è¡¨åæ ‡ï¼š
$$
a=\min(i,\,N-1-i),\quad b=\min(j,\,N-1-j)
$$
åˆ™ `(a,b)` å”¯ä¸€ç¡®å®šè½¨é“ï¼Œå¯ç”¨ `id = a * (N/2)+ b` ç´¢å¼•å…¶è®¡æ•° `k`ã€‚

> **å°ç»“ï¼šåˆ†è½¨é“ã€æ¯è½¨é“å– `min(k,4-k)`ã€å•ç‚¹æ›´æ–°åªæ”¹ ä¸€ä¸ªè½¨é“ï¼Œæ•´ä½“ `O(N^2+U)`ã€‚**

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, U;
    cin >> N >> U;
    vector<string> g(N);
    for (int i = 0; i < N; ++i) cin >> g[i];

    int H = N / 2;                          // number of orbits per row/col
    auto id_of = [&](int i, int j) -> int { // unique id for the 4-cell orbit
        int a = min(i, N - 1 - i);
        int b = min(j, N - 1 - j);
        return a * H + b;
    };

    // Count '#' in each 4-cell orbit
    vector<int> cnt(H * H, 0);
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            int id = id_of(i, j);
            if (g[i][j] == '#') ++cnt[id];
        }
    }

    long long answer = 0;
    for (int id = 0; id < H * H; ++id) {
        int k = cnt[id];
        answer += min(k, 4 - k);
    }

    auto output = [&]() {
        cout << answer << '\n';
    };

    output(); // before any updates

    while (U--) {
        int r, c; cin >> r >> c;
        --r; --c; // 0-index

        int id = id_of(r, c);

        // remove old contribution
        answer -= min(cnt[id], 4 - cnt[id]);

        // toggle cell and update count
        if (g[r][c] == '#') {
            g[r][c] = '.';
            --cnt[id];
        } else {
            g[r][c] = '#';
            ++cnt[id];
        }

        // add new contribution
        answer += min(cnt[id], 4 - cnt[id]);

        output();
    }
    return 0;
}

```

### Problem 2. Making Mexes

é¢˜æ„ï¼šæŠŠæ•°ç»„çš„ mex å˜æˆæ¯ä¸ª `i`çš„æœ€å°‘æ”¹åŠ¨æ•°ã€‚
$$
iâˆˆ[0..N]
$$

### ğŸ“Œ æ€è·¯ï¼š

![idea](./images/8.png)

![idea](./images/9.png)

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;
    vector<long long> cnt(N + 1, 0); // ai in [0..N]

    for (int i = 0; i < N; ++i) {
        int x; cin >> x;
        if (0 <= x && x <= N) ++cnt[x];
        // (x > N cannot happen per constraints, but safe anyway)
    }

    // ans[0] = number of zeros to delete
    cout << cnt[0] << "\n";

    long long miss = 0; // number of j in [0..i-1] with cnt[j] == 0
    for (int i = 1; i <= N; ++i) {
        if (cnt[i - 1] == 0) ++miss;
        // remove all i's, and create all missing values in [0..i-1]
        // each changed i can fill one missing; leftover missing or leftover i's cost extra
        long long ans = max(cnt[i], miss);
        cout << ans << "\n";
    }
    return 0;
}

```

### Problem 3. Printing Sequences

é¢˜æ„ï¼šç”¨æœ€å¤š K æ¬¡ `PRINT` + ä»»æ„å¤šå±‚ `REP` ç”Ÿæˆç»™å®šåºåˆ—

æ€è·¯ï¼šæ ¸å¿ƒæ€è·¯æ˜¯æŠŠç¨‹åºçœ‹æˆç”±ä¸¤ç§ç»„åˆæ„æˆï¼š

1. **ä¸²è”ï¼ˆConcatenationï¼‰**ï¼šæŠŠä¸¤ä¸ªå­ç¨‹åºæ¥åœ¨ä¸€èµ·ï¼Œæ‰€éœ€ `PRINT` æ¬¡æ•°ç›¸åŠ ï¼›
2. **é‡å¤ï¼ˆRepetitionï¼‰**ï¼š`REP t (Q)` æŠŠæŸæ®µå­åºåˆ—æ•´æ®µé‡å¤è‹¥å¹²æ¬¡â€”â€”**ä¸å¢åŠ ** `PRINT` æ¬¡æ•°ï¼ˆä»ç­‰äº `Q` çš„ `PRINT` å¶å­æ•°ï¼‰ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬åªéœ€åˆ¤æ–­ï¼šèƒ½å¦ç”¨è¿™ä¸¤ç§æ“ä½œæŠŠç›®æ ‡åºåˆ—æ‹¼å‡ºæ¥ï¼Œä½¿å¾—**å¶å­ï¼ˆ`PRINT x`ï¼‰çš„æ•°é‡ â‰¤ K**ã€‚è¿™è½¬åŒ–ä¸ºä¸€ä¸ªåŒºé—´ DPã€‚

------

#### åŒºé—´ DP è®¾è®¡

- è®¾åºåˆ—ä¸º `a[0..N-1]`ï¼ˆN â‰¤ 100, K â‰¤ 3ï¼‰ã€‚
- å®šä¹‰ `dp[l][r]`ï¼šæ„é€ å­åºåˆ— `a[l..r]` æ‰€éœ€æœ€å°‘ `PRINT` æ•°ï¼ˆå³æœ€å°‘å¶å­æ•°ï¼‰ã€‚

#### åˆå§‹ä¸è½¬ç§»

- **åŸºåº•ï¼ˆå…¨ç›¸åŒæ®µï¼‰**ï¼šå¦‚æœ `a[l..r]` å…¨éƒ¨ç›¸åŒï¼ˆå€¼éšä¾¿ï¼Œåªè¦ä¸€è‡´ï¼‰ï¼Œå¯ä»¥ï¼š

  ```
  REP (r-l+1)
      PRINT a[l]
  END
  ```

  åªéœ€ **1** æ¬¡ `PRINT`ï¼Œæ‰€ä»¥ `dp[l][r] = 1`ã€‚

- **ä¸²è”**ï¼šå¯¹ä»»æ„åˆ‡åˆ†ç‚¹ `k`ï¼ˆ`l â‰¤ k < r`ï¼‰ï¼š
  $$
  dp[l][r] = \min\big(dp[l][k] + dp[k+1][r]\big)
  $$

- **é‡å¤å‹ç¼©**ï¼šè‹¥ `a[l..r]` å¯ç”±æŸä¸ª**åŸºæ¨¡å¼** `a[l..l+p-1]` é‡å¤æ•´é½é“ºæ»¡ï¼ˆ`len = r-l+1`ï¼Œä¸” `len % p == 0`ï¼Œå¹¶ä¸”æ¯ä¸ªå—éƒ½ä¸åŸºæ¨¡å¼ç›¸åŒï¼‰ï¼Œåˆ™
  $$
  dp[l][r] = \min\big(dp[l][r],\ dp[l][l+p-1]\big)
  $$
  â€”â€”å¤–å±‚åŒ…ä¸€å±‚ `REP (len/p)`ï¼Œ`PRINT` å¶å­æ•°**ä¸å˜**ã€‚

### åˆ¤å®š

- æœ€ç»ˆåˆ¤æ–­ `dp[0][N-1] â‰¤ K` åˆ™è¾“å‡º YESï¼Œå¦åˆ™ NOã€‚

------

#### å¤æ‚åº¦ä¸å®ç°ç»†èŠ‚

- ç›´æ¥å®ç°ï¼š
  - é¢„å¤„ç† `allSame[l][r]` åˆ¤æ–­åŒºé—´æ˜¯å¦å…¨ç›¸åŒï¼ˆO(NÂ²)ï¼‰ã€‚
  - æšä¸¾é•¿åº¦ `len`ï¼Œæšä¸¾åŒºé—´ `(l,r)`ï¼ˆO(NÂ²)ï¼‰ï¼Œ
    - æšä¸¾åˆ‡åˆ†ç‚¹ `k`ï¼ˆO(N)ï¼‰ï¼Œ
    - æšä¸¾åŸºæ¨¡å¼é•¿åº¦ `p`ï¼ˆO(N)ï¼‰ï¼Œå¹¶é€ä½æ¯”å¯¹æ˜¯å¦æ•´é½é‡å¤ï¼ˆæœ€å O(N)ï¼‰ã€‚
  - ç²—ç•¥ä¸Šç•Œ O(NÂ³)ï½O(Nâ´)ï¼Œä½† N=100 å®Œå…¨å¯è¿‡ï¼›å®è·µä¸­å¯æŠŠâ€œæ£€æŸ¥æ•´é½é‡å¤â€åœ¨å¾ªç¯é‡Œåšçº¿æ€§æ¯”å¯¹ï¼Œæ•´ä½“ **O(NÂ³)** è¶³å¤Ÿã€‚
- å°ä¼˜åŒ–ï¼š
  - åœ¨ DP ä¸­ä¸€æ—¦æŸä¸ª `dp[l][r]` å·²ç» â‰¤ Kï¼Œå°±æ²¡å¿…è¦ç»§ç»­å°è¯•æ›´å·®çš„è½¬ç§»ï¼ˆå‰ªæï¼‰ã€‚
  - â€œæ•´é½é‡å¤â€çš„æ£€æŸ¥å¯ä»¥ç”¨å“ˆå¸Œ / Z å‡½æ•° / KMP å‰ç¼€å‡½æ•°åŠ é€Ÿåˆ°å‡æ‘Š O(1) åˆ¤æ–­ï¼Œä½†å¯¹ N=100 æ²¡å¿…è¦ã€‚

ä¸€å¥è¯æ€»ç»“ï¼š

> ç”¨åŒºé—´ DP æ±‚â€œæœ€å°‘ `PRINT` å¶å­æ•°â€ï¼Œè½¬ç§»åŒ…å«**ä¸²è”**ä¸**æ•´æ®µé‡å¤å‹ç¼©**ï¼›æœ€ååˆ¤æ–­æ˜¯å¦ â‰¤ Kã€‚

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;
    while (T--) {
        int N, K;
        cin >> N >> K;
        vector<int> a(N);
        for (int i = 0; i < N; ++i) cin >> a[i];

        const int INF = 1e9;
        vector<vector<int>> dp(N, vector<int>(N, INF));
        vector<vector<bool>> allSame(N, vector<bool>(N, false));

        // Precompute allSame
        for (int l = 0; l < N; ++l) {
            allSame[l][l] = true;
            for (int r = l + 1; r < N; ++r) {
                allSame[l][r] = allSame[l][r - 1] && (a[r] == a[l]);
            }
        }

        // Helper to check if a[l..r] == k repeats of a[l..l+p-1]
        auto isRepeat = [&](int l, int r, int p) -> bool {
            int len = r - l + 1;
            if (p <= 0 || len % p) return false;
            for (int i = l + p; i <= r; ++i) {
                if (a[i] != a[l + (i - l) % p]) return false;
            }
            return true;
        };

        for (int len = 1; len <= N; ++len) {
            for (int l = 0; l + len - 1 < N; ++l) {
                int r = l + len - 1;

                // If all equal -> 1 PRINT with a REP
                if (allSame[l][r]) {
                    dp[l][r] = 1;
                }

                // Concatenation
                for (int k = l; k < r; ++k) {
                    dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r]);
                }

                // Repetition (use smaller base pattern if it tiles the whole segment)
                for (int p = 1; p < len; ++p) { // p = base pattern length
                    if (isRepeat(l, r, p)) {
                        dp[l][r] = min(dp[l][r], dp[l][l + p - 1]);
                    }
                }
            }
        }

        cout << (dp[0][N - 1] <= K ? "YES" : "NO") << "\n";
    }
    return 0;
}

```

