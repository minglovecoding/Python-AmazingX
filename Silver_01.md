## 📚 银组考点1

- 前缀和 + 区间技巧

- DFS/BFS 图搜索

- 树的递归分析

***

## 📘 前缀和与差分讲义

------

### 一、前缀和（Prefix Sum）

### 💡 基本思想

前缀和是一种通过预处理累积和来 **快速求解任意区间和** 的算法技巧。

给定一个长度为 `n` 的数组：
$$
a_1, a_2, \dots, a_n
$$
定义它的**前缀和数组** `S` 为：
$$
S_i = a_1 + a_2 + \dots + a_i \quad (1 \le i \le n)
$$
我们约定 `S_0 = 0`。

------

### 🧮 区间和求法

任意区间 `[l, r]` 的和可由前缀和数组在 **O(1)** 时间得到：
$$
\text{sum}(l, r) = S_r - S_{l-1}
$$

> 即：用区间右端的累积和减去左端之前的累积和。

------

### 🧱 示例

数组：`a = [2, 5, 3, 6, 4]`
 构造前缀和：

```
S = [0, 2, 7, 10, 16, 20]
```

求区间 [2,4] 的和：

```
S[4] - S[1] = 16 - 2 = 14
```

------

### ⚙️ 时间复杂度

| 操作           | 时间复杂度 |
| -------------- | ---------- |
| 构建前缀和数组 | O(n)       |
| 单次区间求和   | O(1)       |
| 多次查询       | O(1) / 次  |

------

### 🧠 典型应用

| 类型       | 举例                            |
| ---------- | ------------------------------- |
| 区间求和   | 快速求 [L,R] 和                 |
| 多维前缀和 | 2D 矩阵求子矩形和               |
| 统计频率   | 统计某种元素在前 k 位的出现次数 |
| 判断平衡   | 左右两部分的和是否相等          |

------

### 🧩 多维扩展（二维前缀和）

二维前缀和用于矩阵区域求和：

定义：
$$
S_{i,j} = \sum_{x=1}^{i}\sum_{y=1}^{j} a_{x,y}
$$
区间求和（子矩形 `[x_1,x_2] *  [y_1,y_2]`）：
$$
\text{sum} = S_{x_2,y_2} - S_{x_1-1,y_2} - S_{x_2,y_1-1} + S_{x_1-1,y_1-1}
$$

------

### 🧰 典型题目

- **USACO Silver 2017 Dec – “Breed Counting”**
- **Leetcode 303 – Range Sum Query Immutable**

------

### 📌 2020 December Problem 2: Rectangular Pasture

**🧩 一、题意回顾：给出 `N` 头奶牛，每头牛在平面上的坐标互不相同。我们要数出：**能被某个轴对齐矩形恰好包围的奶牛子集数量（含空集）**。

##### 🧱 二、算法整体思路

> 通过 **二维前缀和** 统计矩形中点的数量，
>  按 y 坐标枚举矩形的上下边界，
>  按 x 坐标分割出可能的左右边界组合数。

```c++

#include <iostream>
#include <algorithm>
using namespace std;
 
typedef pair<int,int> Point;
bool ycomp(Point p, Point q) { return p.second < q.second; }
 
const int MAX_N = 2500;
int N, Psum[MAX_N+1][MAX_N+1];
Point P[MAX_N];
 
int rsum(int x1, int y1, int x2, int y2)
{
  return Psum[x2+1][y2+1] - Psum[x2+1][y1] - Psum[x1][y2+1] + Psum[x1][y1];
}
//计算矩形 [x1+1..x2+1] × [y1+1..y2+1] 内的牛数。
int main(void)
{
  cin >> N;
  for (int i=0; i<N; i++) {
    int x, y;
    cin >> x >> y;
    P[i] = make_pair(x,y);
  }
  sort(P, P+N); // 按 x 排序
  for (int i=0; i<N; i++) P[i].first = i+1;
  sort(P, P+N, ycomp); // 按 y 排序
  for (int i=0; i<N; i++) P[i].second = i+1;
  for (int i=0; i<N; i++) Psum[P[i].first][P[i].second] = 1;
  for (int i=1; i<=N; i++)
    for (int j=1; j<=N; j++)//Psum[x][y] = 从左下角 (1,1) 到 (x,y) 的矩形中牛的数量。
      Psum[i][j] += Psum[i-1][j] + Psum[i][j-1] - Psum[i-1][j-1];
  
  long long answer = 0;
  for (int i=0; i<N; i++) 
    for (int j=i; j<N; j++) {
      int x1 = min(P[i].first, P[j].first) - 1;
      int x2 = max(P[i].first, P[j].first) - 1;
      answer += rsum(0,i,x1,j) * rsum(x2,i,N-1,j);//y条带内的左侧有多少牛 * y条带内的右侧有多少牛。
    }
  cout << answer + 1 << "\n";//最后加 1 是为了计入空集。
}
```

## 🧩 一、离散化的定义

**离散化（discretization）** 的本质是：

> 把“稀疏而范围巨大的坐标” → 压缩映射到“小范围整数编号”。

即使坐标值原本很大（如 10⁹），
 我们只关心它们之间的**相对顺序**，而不是具体数值。

------

## 🚜 二、为什么要离散化

以本题（Rectangular Pasture）为例：

- 每头牛的坐标 (x, y) 都可能在 0~10⁹ 之间；
- 但最多只有 2500 头牛。

我们关心的是：

> 哪些牛的 x、y 谁在左、谁在右，谁在上、谁在下。

**不需要知道它们具体的数值。**

------

### 🧠 举个例子

原始坐标：

| 牛   | x          | y    |
| ---- | ---------- | ---- |
| 1    | 0          | 2    |
| 2    | 1000000000 | 0    |
| 3    | 500        | 3    |

这些数太大，无法直接建一个 10⁹ × 10⁹ 的网格。
 离散化后：

| 牛   | x 排名 | y 排名 |
| ---- | ------ | ------ |
| 1    | 1      | 2      |
| 2    | 3      | 1      |
| 3    | 2      | 3      |

现在 x, y 均在 [1, N] = [1, 3] 范围内。
 你就能在一个小矩阵（3×3）中处理。

***

### 二、差分数组（Difference Array）

### 💡 基本思想

差分是前缀和的“逆运算”。
 它用于在 **O(1)** 时间内执行区间加法更新，之后再用前缀和恢复原数组。

设原数组为：
$$
a_1, a_2, \dots, a_n
$$
定义它的差分数组：
$$
d_i = a_i - a_{i-1} \quad (a_0 = 0)
$$
那么：
$$
a_i = d_1 + d_2 + \dots + d_i
$$

------

### 🧱 区间更新操作

若要将区间 `[l, r]` 中的所有元素加上某个值 `x`，只需：

```
d[l] += x;
d[r+1] -= x;
```

最后再用一次前缀和恢复即可：
$$
a_i = a_{i-1} + d_i
$$

------

### 🧮 示例

初始数组：`a = [0, 0, 0, 0, 0]`
 我们希望：

1. 区间 [2,4] 加 3
2. 区间 [1,3] 加 2

差分数组变化：

```
初始: d = [0, 0, 0, 0, 0, 0]
操作1: d[2]+=3, d[5]-=3  → d=[0,0,3,0,0,-3]
操作2: d[1]+=2, d[4]-=2  → d=[0,2,3,0,-2,-3]
```

最后恢复：

```
a = [2, 5, 5, 3, 1]
```

------

### ⚙️ 时间复杂度

| 操作                | 时间复杂度 |
| ------------------- | ---------- |
| 单次区间加法        | O(1)       |
| 多次更新 + 一次恢复 | O(n + q)   |

------

### 🧠 典型应用

| 应用场景       | 举例                     |
| -------------- | ------------------------ |
| 区间加 / 减    | 大量区间更新             |
| 区间覆盖       | 统计每个点被多少区间覆盖 |
| 动态变化统计   | 频率、温度、速度变化问题 |
| 前缀和反向推导 | 通过变化量还原原值       |

------

### 🧩 差分与前缀和的关系

| 操作     | 数学关系              | 含义       |
| -------- | --------------------- | ---------- |
| 前缀和   | `S_i = S_{i-1} + a_i` | 累积求和   |
| 差分     | `d_i = a_i - a_{i-1}` | 相邻差值   |
| 区间加法 | `d[l]+=x, d[r+1]-=x`  | 延迟标记   |
| 区间恢复 | `a[i]=a[i-1]+d[i]`    | 重建原数组 |

------

### 🧰 典型题目

- **USACO Silver 2018 Jan – “Lifeguards”**
- **2022 Feb** **Silver** **Redistributing Gifts**
- **Leetcode 370 – Range Addition**

------

### 📌 **USACO Bronze 2021 Dec – “Air Cownditioning”**

🧩 思路：把每个栏位“需要的改变量”记为
 `d_i = p_i - t_i`。

一次指令就是对一段连续区间整体 +1 或 -1。把所有指令叠加后，正好要把数组 `t` 变到 `p`，也就是把“改变量数组”做出来。最少指令数可以用下面任一等价公式在线性时间算出：

- 直观贪心（从左到右“开/关”区间）
   设 `d_0=0`，答案
  $$
  \text{ans}=\sum_{i=1}^{N}\max\bigl(0,\, d_i-d_{i-1}\bigr)\;+\;\max(0,\,-d_N).
  $$
  含义：每当 `d` 相比前一位上升，就需要新开这么多“+1 区间”；走到末尾如果还大于 0 就不用补，但如果末尾是负的，还得“关掉”这些 -1 区间（即再加 `max(0,-d_N)`）。

代码：

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int N;
    if (!(cin >> N)) return 0;
    vector<long long> p(N+1), t(N+1), d(N+1);
    for (int i = 1; i <= N; ++i) cin >> p[i];
    for (int i = 1; i <= N; ++i) cin >> t[i];
    for (int i = 1; i <= N; ++i) d[i] = p[i] - t[i];

    long long ans = 0;
    long long prev = 0; // d[0] = 0
    for (int i = 1; i <= N; ++i) {
        if (d[i] > prev) ans += d[i] - prev; // 开新的 +1 区间
        prev = d[i];
    }
    if (d[N] < 0) ans += -d[N]; // 关掉末尾的 -1 区间
    cout << ans << "\n";
    return 0;
}
```

## 三、前缀和与差分的对比总结

| 特性       | 前缀和              | 差分                |
| ---------- | ------------------- | ------------------- |
| 用途       | 快速求区间和        | 快速区间加法        |
| 构造方式   | 累加                | 相减                |
| 查询复杂度 | O(1)                | 需恢复后 O(1)       |
| 更新复杂度 | O(n)                | O(1)                |
| 常见题型   | 区间求和、统计      | 区间更新、覆盖计数  |
| 数学关系   | `S_i = S_{i-1}+a_i` | `a_i = a_{i-1}+d_i` |

------

## 四、结合使用的技巧

有时需要「区间更新 + 区间查询」，可将两者结合使用：

1. 先用 **差分数组** 快速进行区间更新；
2. 再用 **前缀和** 计算最终数组；
3. 最后可继续构建新的前缀和数组以支持查询。

------

## 五、总结口诀 🧩

> 查区间 → 前缀；
>  改区间 → 差分；
>查改皆快，思路通神。
