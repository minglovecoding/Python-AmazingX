## USACO 2024 December Contest, Silver

### Problem 1. Cake Game

题意：两头牛Bessie和Elsie轮流进行操作，Bessie堆叠两堆草为一堆，Elsie在最左侧或最右侧取走一堆草，当最终只有一堆草时，Bessie取走。Elsie和Bessie都遵循最优策略，即都想要最多的草。Bessie首先开始操作，问Bessie和Elsie最优的结果是什么？

```
2
4
40 30 20 10
4
10 20 30 40
```

思路：Elsie肯定是在左右两边取数，由于题意告诉我们是偶数，所以Elsie总共在左右两边取N/2-1个。Bessie会执行N/2次操作，最后一次操作后只留一个数即为Bessie取的值。题意告诉两头牛都执行最优策略，即两头牛都想尽可能取多一点值，所以Bessie执行操作时是想让最后一个草的值更大，而不是让Elsie吃掉。对Elsie遍历所有可能(左0 右N/2-1 ... 左N/2-1 右0)，找出最大值。

```python
T=int(input())
while T:
    T-=1
    Elsie=0
    N=int(input())
    A=list(map(int,input().split()))
    pre=[0]*(N+1)
    suf=[0]*(N+2)
    for i in range(1,N+1):
        pre[i]=pre[i-1]+A[i-1]
    for i in range(N,0,-1):
        suf[i]=suf[i+1]+A[i-1]
    for i in range(0,N//2):#0-N//2-1
        Elsie=max(Elsie,pre[i]+suf[N+1-(N//2-1-i)])
    print(pre[N]-Elsie,Elsie)
```

### Problem 2. Deforestation

题意：T个测试样例，每个样例有N个数，共有K个约束条件，从位置l到r必须有t个树存在。要求能砍伐树的最大数量，即求满足约束条件的最小树。样例未给出特殊值，说明测试样例都能符合要求。

```
3
7 1
8 4 10 1 2 6 7
2 9 3
7 2
8 4 10 1 2 6 7
2 9 3
1 10 1
7 2
8 4 10 1 2 6 7
2 9 3
1 10 4

4
4
3
```

![Tree](/Users/zhoumingzhao/Desktop/Python-AmazingX/images/3.png)

思路：1.一种是对约束l进行排序，从右向左添加树木，基于区间约束的贪心+树状数组+离散化，代码较繁琐。2.另一种是对约束r进行排序，从左至右添加靠近r的树（越靠近右边下一个约束要插入的树可能越少）。用planted表示种的树，并按升序插入，用bisect去查询已种植树l到r中树的数量。逐个对每个约束进行处理，首先将能插入的树加入到stack里，依次弹出stack的树即为最靠近r的树。题意未出现特殊情况，所以总有选择能满足条件。当处理完所有约束后，返回N-len(planted)值即为农夫可以开拓田地的最大值。

```Python
import bisect
def solve():
    N,K=map(int,input().split())
    A=list(map(int,input().split()))
    _K=[]
    stack=[]
    planted=[]
    for _ in range(K):
        l,r,t=map(int,input().split())
        _K.append((r,l,t))
    _K.sort()
    A.sort()
    index=0
    for r,l,t in _K:
        while index<N and A[index]<=r:
            stack.append((A[index]))
            index+=1
        #可选的树全在stack里,尽可能选靠右的树,所以逐个pop
        #二分查找[l.r]的树是否满足限制
        current_t=bisect.bisect_right(planted,r)-bisect.bisect_left(planted,l)
        while current_t<t:
            assert stack, "无可选树但约束未满足，说明题目输入有误"
            pos=stack.pop()
            bisect.insort(planted,pos)
            current_t+=1
    print(N-len(planted))

def main():
    T=int(input())
    for _ in range(T):
        solve()

if __name__=="__main__":
    main()

```

数状数组
![树状数组](/Users/zhoumingzhao/Desktop/Python-AmazingX/images/1.png)
![code](/Users/zhoumingzhao/Desktop/Python-AmazingX/images/2.png)

### Problem 3. 2D Conveyor Belt

题意：一个N✖️N的网格，每个网格可以放一个传送带。传送带有上下左右四个方向，表示当物品落入到此网格时会向传送带方向移动，传送带也可以传到网格外。初始化所有网格都是**`？`**，接下来Q天内，在（row，col）位置放入传送带，剩下的**`？`**网格可以任意放传送带，求最小不可到达边界的网格数量。

思路：当放入的传送带越来越多，最后的不可到达网格值可能越多。不可到达网格有两种特征，一种是形成了一个闭环，且所有的闭环网格都不可到达边界。二是**`？`**被传送带包围，无论上下左右最终都不可到达边界。网格四周标记为1，只需对网格最外侧网格进行Dfs深搜即可算出可到达边界网格。由于网格未放置传送带时最后填充时有四个方向可以选，因此可以先算放置Q个传送带的可到达网格，再逐个从第Q个操作往回回滚并更新网格值为**`?`**,只需DFS该网格值即可算出可到达网格值，不可到达网格值即为n*n-ans[i]。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1000+10;
const int Q=2e5+10;
const int dx[]={-1,0,1,0};
const int dy[]={0,1,0,-1};
int tot=0,n,q,ans[Q],g[N][N],s[N][N];
struct Node{
    int x,y,d;
}a[Q];
inline bool inb(int x,int y){
    return 1<=x && x<=n && 1<=y && y<=n;
}
void dfs(int x,int y){
    if(s[x][y]) return;
    bool flag=false;
    if(g[x][y]==-1){
        for(int i=0;i<4;i++){
            int nx=x+dx[i],ny=y+dy[i];
            if(s[nx][ny]) flag=true;
        }
    }else{
        int nx=x+dx[g[x][y]],ny=y+dy[g[x][y]];
        if(s[nx][ny]) flag=true;
    }
    if(!flag) return;
    ++tot;
    s[x][y]=1;
    for(int i=0;i<4;i++){
        int nx=x+dx[i],ny=y+dy[i];
        if(inb(nx,ny)) dfs(nx,ny);
    }
}
int main(){
    cin>>n>>q;
    memset(g,-1,sizeof(g));
    for(int i=1;i<=q;i++){
         char c;
         cin>>a[i].x>>a[i].y>>c;
         if(c=='U') a[i].d=0;
         else if(c=='R') a[i].d=1;
         else if(c=='D') a[i].d=2;
         else a[i].d=3;
         g[a[i].x][a[i].y]=a[i].d;
    }
    for(int i=1;i<=n;i++) s[0][i]=s[n+1][i]=s[i][0]=s[i][n+1]=1;
    for(int i=1;i<=n;i++){
        dfs(1,i);
        dfs(n,i);
        dfs(i,1);
        dfs(i,n);
    }
    ans[q]=tot;
    for(int i=q;i>=2;i--){
        g[a[i].x][a[i].y]=-1;
        dfs(a[i].x,a[i].y);
        ans[i-1]=tot;
    }
    for(int i=1;i<=q;i++){
        cout<<n*n-ans[i]<<endl;
    }
    return 0;
}
```

***

## USACO 2024 December Contest, Bronze

题意：

思路：

```python
def alg(N):
    digits = 0
    while 10**digits < N:
        digits += 1
    
    answer = 0
    for curdigits in range(1, digits+1):
        upper = int('5'+'0'*(curdigits-1))-1
        upper = min(N, upper)  
        lower = int('4'*curdigits)
        answer += max(0, upper - lower)
    return answer
 
T = int(input().strip())
for _ in range(T):
    N = int(input().strip())
    print(alg(N))
```

