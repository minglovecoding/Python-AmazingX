## USACO 2024 December Contest, Silver

### Problem 1. Cake Game

题意：两头牛Bessie和Elsie轮流进行操作，Bessie堆叠两堆草为一堆，Elsie在最左侧或最右侧取走一堆草，当最终只有一堆草时，Bessie取走。Elsie和Bessie都遵循最优策略，即都想要最多的草。Bessie首先开始操作，问Bessie和Elsie最优的结果是什么？

```
2
4
40 30 20 10
4
10 20 30 40
```

思路：Elsie肯定是在左右两边取数，由于题意告诉我们是偶数，所以Elsie总共在左右两边取N/2-1个。Bessie会执行N/2次操作，最后一次操作后只留一个数即为Bessie取的值。题意告诉两头牛都执行最优策略，即两头牛都想尽可能取多一点值，所以Bessie执行操作时是想让最后一个草的值更大，而不是让Elsie吃掉。对Elsie遍历所有可能(左0 右N/2-1 ... 左N/2-1 右0)，找出最大值。

```python
T=int(input())
while T:
    T-=1
    Elsie=0
    N=int(input())
    A=list(map(int,input().split()))
    pre=[0]*(N+1)
    suf=[0]*(N+2)
    for i in range(1,N+1):
        pre[i]=pre[i-1]+A[i-1]
    for i in range(N,0,-1):
        suf[i]=suf[i+1]+A[i-1]
    for i in range(0,N//2):#0-N//2-1
        Elsie=max(Elsie,pre[i]+suf[N+1-(N//2-1-i)])
    print(pre[N]-Elsie,Elsie)
```

### Problem 2. Deforestation

题意：T个测试样例，每个样例有N个数，共有K个约束条件，从位置l到r必须有t个树存在。要求能砍伐树的最大数量，即求满足约束条件的最小树。样例未给出特殊值，说明测试样例都能符合要求。

```
3
7 1
8 4 10 1 2 6 7
2 9 3
7 2
8 4 10 1 2 6 7
2 9 3
1 10 1
7 2
8 4 10 1 2 6 7
2 9 3
1 10 4

4
4
3
```

![Tree](/Users/zhoumingzhao/Desktop/Python-AmazingX/images/3.png)

思路：1.一种是对约束l进行排序，从右向左添加树木，基于区间约束的贪心+树状数组+离散化，代码较繁琐。2.另一种是对约束r进行排序，从左至右添加靠近r的树（越靠近右边下一个约束要插入的树可能越少）。用planted表示种的树，并按升序插入，用bisect去查询已种植树l到r中树的数量。逐个对每个约束进行处理，首先将能插入的树加入到stack里，依次弹出stack的树即为最靠近r的树。题意未出现特殊情况，所以总有选择能满足条件。当处理完所有约束后，返回N-len(planted)值即为农夫可以开拓田地的最大值。

```Python
import bisect
def solve():
    N,K=map(int,input().split())
    A=list(map(int,input().split()))
    _K=[]
    stack=[]
    planted=[]
    for _ in range(K):
        l,r,t=map(int,input().split())
        _K.append((r,l,t))
    _K.sort()
    A.sort()
    index=0
    for r,l,t in _K:
        while index<N and A[index]<=r:
            stack.append((A[index]))
            index+=1
        #可选的树全在stack里,尽可能选靠右的树,所以逐个pop
        #二分查找[l.r]的树是否满足限制
        current_t=bisect.bisect_right(planted,r)-bisect.bisect_left(planted,l)
        while current_t<t:
            assert stack, "无可选树但约束未满足，说明题目输入有误"
            pos=stack.pop()
            bisect.insort(planted,pos)
            current_t+=1
    print(N-len(planted))

def main():
    T=int(input())
    for _ in range(T):
        solve()

if __name__=="__main__":
    main()

```

数状数组
![树状数组](/Users/zhoumingzhao/Desktop/Python-AmazingX/images/1.png)
![code](/Users/zhoumingzhao/Desktop/Python-AmazingX/images/2.png)

### Problem 3. 2D Conveyor Belt

题意：一个N✖️N的网格，每个网格可以放一个传送带。传送带有上下左右四个方向，表示当物品落入到此网格时会向传送带方向移动，传送带也可以传到网格外。初始化所有网格都是**`？`**，接下来Q天内，在（row，col）位置放入传送带，剩下的**`？`**网格可以任意放传送带，求最小不可到达边界的网格数量。

思路：当放入的传送带越来越多，最后的不可到达网格值可能越多。不可到达网格有两种特征，一种是形成了一个闭环，且所有的闭环网格都不可到达边界。二是**`？`**被传送带包围，无论上下左右最终都不可到达边界。网格四周标记为1，只需对网格最外侧网格进行Dfs深搜即可算出可到达边界网格。由于网格未放置传送带时最后填充时有四个方向可以选，因此可以先算放置Q个传送带的可到达网格，再逐个从第Q个操作往回回滚并更新网格值为**`?`**,只需DFS该网格值即可算出可到达网格值，不可到达网格值即为n*n-ans[i]。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1000+10;
const int Q=2e5+10;
const int dx[]={-1,0,1,0};
const int dy[]={0,1,0,-1};
int tot=0,n,q,ans[Q],g[N][N],s[N][N];
struct Node{
    int x,y,d;
}a[Q];
inline bool inb(int x,int y){
    return 1<=x && x<=n && 1<=y && y<=n;
}
void dfs(int x,int y){
    if(s[x][y]) return;
    bool flag=false;
    if(g[x][y]==-1){
        for(int i=0;i<4;i++){
            int nx=x+dx[i],ny=y+dy[i];
            if(s[nx][ny]) flag=true;
        }
    }else{
        int nx=x+dx[g[x][y]],ny=y+dy[g[x][y]];
        if(s[nx][ny]) flag=true;
    }
    if(!flag) return;
    ++tot;
    s[x][y]=1;
    for(int i=0;i<4;i++){
        int nx=x+dx[i],ny=y+dy[i];
        if(inb(nx,ny)) dfs(nx,ny);
    }
}
int main(){
    cin>>n>>q;
    memset(g,-1,sizeof(g));
    for(int i=1;i<=q;i++){
         char c;
         cin>>a[i].x>>a[i].y>>c;
         if(c=='U') a[i].d=0;
         else if(c=='R') a[i].d=1;
         else if(c=='D') a[i].d=2;
         else a[i].d=3;
         g[a[i].x][a[i].y]=a[i].d;
    }
    for(int i=1;i<=n;i++) s[0][i]=s[n+1][i]=s[i][0]=s[i][n+1]=1;
    for(int i=1;i<=n;i++){
        dfs(1,i);
        dfs(n,i);
        dfs(i,1);
        dfs(i,n);
    }
    ans[q]=tot;
    for(int i=q;i>=2;i--){
        g[a[i].x][a[i].y]=-1;
        dfs(a[i].x,a[i].y);
        ans[i-1]=tot;
    }
    for(int i=1;i<=q;i++){
        cout<<n*n-ans[i]<<endl;
    }
    return 0;
}
```

***

## USACO 2024 December Contest, Bronze

##### PROBLEM 1. ROUNDABOUT ROUNDING

题意：四舍五入到10的幂，Bessie从右至左数第b个数，if x>=5，a+=10^b。从右侧到第二个数位所有数字都为0。Elsie是链式舍入，即从10^1舍入到最接近的10^b。输入一个N，求有多少个数在N范围内用四舍五入的方法不同。需要注意的是b为正整数即>=1，而Elsie是从10^1开始舍入。

思路：推演如下：

![bronze1](/Users/zhoumingzhao/Desktop/Python-AmazingX/images/4.png)

```python
def cnt_diff(N):
    digits=len(str(N))
    ans=0
    for digit in range(1,digits+1):
        upper=min(N,int('5'+'0'*(digit-1))-1)
        lower=int('4'*digit)
        ans+=max(upper-lower,0)
    return ans

T=int(input())
for _ in range(T):
    N=int(input())
    print(cnt_diff(N))
```

```c++
#include <bits/stdc++.h>
using namespace std;

long long cnt_diff(long long N) {
    // 计算 N 的位数
    int digits = (int)to_string(N).size();

    // 预计算 10^k，k=0..18（long long 安全范围内）
    static long long pow10[19];
    static bool inited = false;
    if (!inited) {
        pow10[0] = 1;
        for (int i = 1; i <= 18; ++i) pow10[i] = pow10[i - 1] * 10;
        inited = true;
    }

    long long ans = 0;
    long long lower = 0; // 依次构造 4, 44, 444, ...

    for (int d = 1; d <= digits; ++d) {
        lower = lower * 10 + 4; // 相当于 int('4'*d)

        // 上界：min(N, 5*10^(d-1) - 1)
        // 注意 d-1 最大为 18，5*10^18 仍在 long long 范围内
        long long upper_cap = 5 * pow10[d - 1] - 1;
        long long upper = min(N, upper_cap);

        if (upper > lower) ans += (upper - lower);
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int T;
    cin >> T;
    while (T--) {
        long long N;
        cin >> N;
        cout << cnt_diff(N) << '\n';
    }
    return 0;
}

```

```c++
#include <bits/stdc++.h>
using namespace std;

long long cnt_diff(long long N) {
    int digits = (int)to_string(N).size();
    long long ans = 0;

    for (int digit = 1; digit <= digits; ++digit) {
        // upper = min(N, int('5' + '0'*(digit-1)) - 1)
        long long upper = 0;
        {
            string s = "5" + string(digit - 1, '0'); // "5", "50", "500", ...
            long long bound = stoll(s) - 1;          // 4, 49, 499, ...
            upper = min(N, bound);
        }

        // lower = int('4' * digit)  -> "4", "44", "444", ...
        long long lower = stoll(string(digit, '4'));

        if (upper > lower) ans += (upper - lower);  // max(upper - lower, 0)
        // 注意：与原 Python 一样，不包含 lower 本身
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;
    while (T--) {
        long long N;
        cin >> N;
        cout << cnt_diff(N) << '\n';
    }
    return 0;
}
//std::stoll 是 C++ <string> 里的函数，用来把字符串转换成 long long 整数
```



##### Problem 2. Farmer John's Cheese Block

题意：Farmer John每次从N✖️N✖️N的立方体取一块立方体的奶酪，每次取出之后 ，更新1✖️1✖️N的奶酪可以插入到立方体的方案数。测试第一行N代表立方体大小，Q代表取的次数。

思路：由于是用1✖️1✖️N的奶酪插进立方体，所以最多有N✖️N✖️N方案，每种方案都是1✖️1的底占着3个轴面里的某一块位置。我们能对3个轴面的每一个位置设置一个N值，每次挖一块奶酪，在3个不同轴面映射的底都-1。当底为0时，说明以此位置为底能满足插入奶酪要求，因此每次都能线性输出一个方案值。

```python
class cheese_block:
    def __init__(self,n):
        self.n=n 
        self.res=0
        self.xy=[[n]*n for _ in range(n)]
        self.xz=[[n]*n for _ in range(n)]
        self.yz=[[n]*n for _ in range(n)]
    def carve(self,x,y,z):
        self.xy[x][y]-=1
        self.xz[x][z]-=1
        self.yz[y][z]-=1
        self.res+=(self.xy[x][y]==0)+(self.xz[x][z]==0)+(self.yz[y][z]==0)
    def ans(self):
        return self.res

N,Q=map(int,input().split())
cb=cheese_block(N)
for _ in range(Q):
    x,y,z=map(int,input().split())
    cb.carve(x,y,z)
    print(cb.ans())
```

```c++
#include <bits/stdc++.h>
using namespace std;

struct CheeseBlock {
    int n;
    int res;
    vector<vector<int>> xy, xz, yz;

    CheeseBlock(int n_) : n(n_), res(0),
        xy(n, vector<int>(n, n)),
        xz(n, vector<int>(n, n)),
        yz(n, vector<int>(n, n)) {}

    void carve(int x, int y, int z) {
        --xy[x][y];
        --xz[x][z];
        --yz[y][z];
        res += (xy[x][y] == 0) + (xz[x][z] == 0) + (yz[y][z] == 0);
    }

    int ans() const { return res; }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, Q;
    cin >> N >> Q;

    CheeseBlock cb(N);
    for (int i = 0; i < Q; ++i) {
        int x, y, z;
        cin >> x >> y >> z;   // assumes 0-based indices as in the Python version
        cb.carve(x, y, z);
        cout << cb.ans() << '\n';
    }
    return 0;
}
//struct或class
//二维数组vector<vector<int>>用法
//空间几何
```

##### Problem 3. It's Mooin' Time

题意：Farmer John下载一行字符串，其中可能会出现一个字符错误。哞哞叫是xyy，如果出现了F次，则是Bessie发出的哞叫，求所有Bessie发出的眸叫。

思路：逐步替换每一个字母为26个字母，用哈希表计算字符的次数，如果cnt[xyy]>=F，将其加入set集合值。最终打印set集合。

```python
from collections import defaultdict
N,F=map(int,input().split())
S=input()
moos=set()
#替换字符

def find_moos(s):
    cnt=defaultdict(int)
    for i in range(N-2):
        if s[i]!=s[i+1] and s[i+1]==s[i+2]:
            cnt[s[i:i+3]]+=1
            if cnt[s[i:i+3]]>=F:
                moos.add(s[i:i+3])

for i in range(N):
    for j in range(26):
        _S=S[:i]+chr(ord('a')+j)+S[i+1:]
        find_moos(_S)

moos=sorted(moos)
print(len(moos))
for moo in moos:
    print(moo)

```

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    //ios::sync_with_stdio(false);
    //cin.tie(nullptr);

    int N, F;
    cin >> N >> F;
    string S;
    cin >> S;

    set<string> moos;  // sorted unique substrings meeting the condition

    auto find_moos = [&](const string &s) {
        unordered_map<string, int> cnt;
        for (int i = 0; i + 2 < N; ++i) {
            if (s[i] != s[i + 1] && s[i + 1] == s[i + 2]) {
                string t = s.substr(i, 3);
                if (++cnt[t] >= F) moos.insert(t);
            }
        }
    };

    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < 26; ++j) {
            string T = S;
            T[i] = char('a' + j);
            find_moos(T);
        }
    }

    cout << moos.size() << '\n';
    for (const auto &moo : moos) cout << moo << '\n';
    return 0;
}
//lambda函数
//哈希表unordered_map<string,int>
//set容器
//string的substr用法
```
